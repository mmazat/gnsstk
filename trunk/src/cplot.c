/**
\file    cplot.c
\brief   C functions for 2D plotting directly to a compressed bitmap.

\author  Glenn D. MacGougan (GDM)
\date    2008-04-23
\since   2007-12-19

\b "LICENSE INFORMATION" \n
Copyright (c) 2007, refer to 'author' doxygen tags \n
All rights reserved. \n

Redistribution and use in source and binary forms, with or without
modification, are permitted provided the following conditions are met: \n

- Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer. \n
- Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution. \n
- The name(s) of the contributor(s) may not be used to endorse or promote 
  products derived from this software without specific prior written 
  permission. \n

THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND ANY EXPRESS 
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.
*/

#include <stdio.h>  // for FILE*
#include <stdlib.h> // for calloc, malloc, free
#include <string.h> // for strlen, sprintf, strstr, strcmp, and others
#include <ctype.h>  // for isalpha
#include <math.h>
#include <float.h>
#include "basictypes.h"
#include "cplot.h"

// deal with msvc empry projects
#ifndef WIN32
  #ifdef _WIN32
    #define WIN32
  #endif
#endif

#if defined _MSC_VER && _MSC_VER < 1400
#define _CRT_SECURE_NO_DEPRECATE
#endif

#ifndef _MSC_VER
#define _CRT_SECURE_NO_DEPRECATE
#endif

//#define INTEL_IPPS

#ifdef INTEL_IPPS // the intel performance primitives acceleration libraries
  #include <ippcore.h>    
  #include <ipps.h>
  #include <ippvm.h>
  #include <ippdc.h>
  // you must call "ippStaticInit();" before using this class! if IPPS is enabled
  // In Windows, for static linking you must include ippcore.lib and ipps.lib
  // in your project
#endif

#define CPLOT_SIZEOF_BITMAPFILEHEADER (14) //!< True size of disk (one byte packing required).
#define CPLOT_SIZEOF_BITMAPINFOHEADER (40) //!< True size of disk (one byte packing required).
  
#define CPLOT_RGB_WHITE       { 255, 255, 255, 0 }
#define CPLOT_RGB_BLACK       {   0,   0,   0, 0 }
#define CPLOT_RGB_BLUE        { 255,   0,   0, 0 }
#define CPLOT_RGB_GREEN       {   0, 128,   0, 0 }
#define CPLOT_RGB_CYAN        { 255, 255,   0, 0 }
#define CPLOT_RGB_RED         {   0,   0, 255, 0 }
#define CPLOT_RGB_INDIANRED   {   0,   0, 128, 0 }
#define CPLOT_RGB_YELLOW      {   0, 255, 255, 0 }
#define CPLOT_RGB_LIMEGREEN   {   0, 255,   0, 0 }
#define CPLOT_RGB_DARKBLUE    { 128,  64,   0, 0 }
#define CPLOT_RGB_BABYBLUE    { 255, 128,   0, 0 }
#define CPLOT_RGB_PAISLYBLUE  { 192, 128,   0, 0 }
#define CPLOT_RGB_LIGHTPURPLE { 255,   0, 128, 0 }
#define CPLOT_RGB_PURPLE      { 255,   0, 128, 0 }
#define CPLOT_RGB_DARKPURPLE  { 128,   0,  64, 0 }
#define CPLOT_RGB_PINK        { 255, 128, 255, 0 }
#define CPLOT_RGB_GREYPURPLE  { 192, 128, 128, 0 }
#define CPLOT_RGB_BROWN       {  64,  64, 128, 0 }
#define CPLOT_RGB_GREY        { 128, 128, 128, 0 }
#define CPLOT_RGB_LIGHTGREY   { 192, 192, 192, 0 }
#define CPLOT_RGB_MAGENTA     { 128,   0, 128, 0 }
#define CPLOT_RGB_ORANGE      {   0, 128, 255, 0 }

#define CPLOT_LARGEFONT        (14)  //!< The width and height of CPLOT's large font.
#define CPLOT_LARGEFONT_NBYTES (196) //!< The number of bytes in a large font letter.
#define CPLOT_SMALLFONT_HGT    (7)  //!< The heigHt of CPLOT's small font.
#define CPLOT_SMALLFONT_WIDTH  (6)  //!< The width of CPLOT's small font.
#define CPLOT_SMALLFONT_NBYTES (42) //!< The number of bytes in a small font letter.

#define CPLOT_PIXELS_PER_CM    (38) //!< The number of pixels per centimeter.

#define CPLOT_POINT_SIZE       (5)  //!< The width/height for a point [pixels].
#define CPLOT_LARGEPOINT_SIZE  (8)  //!< The width/height for a large point [pixels].

#define CPLOT_DEFAULT_PLOT_WIDTH_CM  (15) //!< The default plot width [cm].
#define CPLOT_DEFAULT_PLOT_HEIGHT_CM (13) //!< The default plot height [cm].


typedef unsigned char  byte;


/*
const CPLOT_structRGB kRGB_White       = CPLOT_RGB_WHITE;
const CPLOT_structRGB kRGB_Black       = CPLOT_RGB_BLACK;
const CPLOT_structRGB kRGB_Blue        = CPLOT_RGB_BLUE;
const CPLOT_structRGB kRGB_Green       = CPLOT_RGB_GREEN;
const CPLOT_structRGB kRGB_Cyan        = CPLOT_RGB_CYAN;
const CPLOT_structRGB kRGB_Red         = CPLOT_RGB_RED;
const CPLOT_structRGB kRGB_IndianRed   = CPLOT_RGB_INDIANRED;
const CPLOT_structRGB kRGB_Yellow      = CPLOT_RGB_YELLOW;
const CPLOT_structRGB kRGB_LimeGreen   = CPLOT_RGB_LIMEGREEN;
const CPLOT_structRGB kRGB_DarkBlue    = CPLOT_RGB_DARKBLUE;
const CPLOT_structRGB kRGB_BabyBlue    = CPLOT_RGB_BABYBLUE;
const CPLOT_structRGB kRGB_PaislyBlue  = CPLOT_RGB_PAISLYBLUE;
const CPLOT_structRGB kRGB_LightPurple = CPLOT_RGB_LIGHTPURPLE;
const CPLOT_structRGB kRGB_Purple      = CPLOT_RGB_PURPLE;
const CPLOT_structRGB kRGB_DarkPurple  = CPLOT_RGB_DARKPURPLE;
const CPLOT_structRGB kRGB_Pink        = CPLOT_RGB_PINK;
const CPLOT_structRGB kRGB_GreyPurple  = CPLOT_RGB_GREYPURPLE;
const CPLOT_structRGB kRGB_Brown       = CPLOT_RGB_BROWN;
const CPLOT_structRGB kRGB_Grey        = CPLOT_RGB_GREY;
const CPLOT_structRGB kRGB_LightGrey   = CPLOT_RGB_LIGHTGREY;
const CPLOT_structRGB kRGB_Magenta     = CPLOT_RGB_MAGENTA;
const CPLOT_structRGB kRGB_Orange      = CPLOT_RGB_ORANGE;
*/

const CPLOT_structColorTable CPLOT_DefaultColorTable = {
  CPLOT_RGB_WHITE,
  CPLOT_RGB_BLACK,
  CPLOT_RGB_BLUE,
  CPLOT_RGB_GREEN,
  CPLOT_RGB_PURPLE,
  CPLOT_RGB_MAGENTA,
  CPLOT_RGB_DARKBLUE,
  CPLOT_RGB_INDIANRED,
  CPLOT_RGB_BABYBLUE,
  CPLOT_RGB_PAISLYBLUE,
  CPLOT_RGB_LIGHTPURPLE,
  CPLOT_RGB_DARKPURPLE,
  CPLOT_RGB_GREYPURPLE,
  CPLOT_RGB_BROWN,
  CPLOT_RGB_RED,
  CPLOT_RGB_PINK,
  CPLOT_RGB_YELLOW,
  CPLOT_RGB_ORANGE,
  CPLOT_RGB_CYAN,
  CPLOT_RGB_LIMEGREEN,
  CPLOT_RGB_GREY,
  CPLOT_RGB_LIGHTGREY,
};





const byte CPLOT_Point[CPLOT_POINT_SIZE][CPLOT_POINT_SIZE] =
 {{ 0,0,1,0,0 },
  { 0,1,1,1,0 },
  { 1,1,1,1,1 },
  { 0,1,1,1,0 },
  { 0,0,1,0,0 },};      

const byte CPLOT_LargePoint[CPLOT_LARGEPOINT_SIZE][CPLOT_LARGEPOINT_SIZE] =
 {{ 0,0,1,1,0,0 },
  { 0,1,1,1,1,0 },
  { 1,1,1,1,1,1 },
  { 1,1,1,1,1,1 },
  { 0,1,1,1,1,0 },
  { 0,0,1,1,0,0 },};


const byte CPLOT_LARGEFONT_sigma[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,1,1,1,1,1,1,1 },
{ 0,0,1,1,1,1,1,1,1,1,1,1,1,1 },
{ 0,1,1,1,0,0,0,0,1,1,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,1,1,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,1,1,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,1,1,0,0,0 },
{ 0,0,1,1,0,0,0,0,1,1,1,0,0,0 },
{ 0,0,0,1,1,1,1,1,1,1,0,0,0,0 },
{ 0,0,0,0,1,1,1,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_A[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_B[CPLOT_LARGEFONT][CPLOT_LARGEFONT] =  //11
{
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 }, 
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_C[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_D[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 }, 
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 }, 
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 }, 
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_E[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_F[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_G[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_H[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_I[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //3
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_J[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_K[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_L[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_M[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //13
{
{ 1,1,1,0,0,0,0,0,1,1,1,0,0,0 },
{ 1,1,1,0,0,0,0,0,1,1,1,0,0,0 },
{ 1,1,1,1,0,0,0,1,1,1,1,0,0,0 },
{ 1,1,1,1,0,0,0,1,1,1,1,0,0,0 },
{ 1,1,0,1,1,0,1,1,0,1,1,0,0,0 },
{ 1,1,0,1,1,0,1,1,0,1,1,0,0,0 },
{ 1,1,0,1,1,0,1,1,0,1,1,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
{ 1,1,0,0,0,1,0,0,0,1,1,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_N[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,1,1,1,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_O[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
{ 0,1,1,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_P[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_Q[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 0,1,1,0,0,1,1,1,1,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,1,1,0,0,0,0 },   
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_R[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_S[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_T[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_U[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_V[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_W[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //14
{
{ 1,1,0,0,0,1,1,1,0,0,0,1,1,0 },
{ 1,1,0,0,0,1,1,1,0,0,0,1,1,0 },
{ 1,1,1,0,0,1,1,1,0,0,1,1,1,0 },
{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
{ 0,1,1,0,1,0,0,0,1,0,1,1,0,0 },
{ 0,0,1,1,1,0,0,0,1,1,1,0,0,0 },
{ 0,0,1,1,1,0,0,0,1,1,1,0,0,0 },
{ 0,0,1,1,1,0,0,0,1,1,1,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_X[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_Y[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_Z[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_a[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_b[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_c[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_d[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_e[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_f[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_g[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_h[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },   
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_i[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_j[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_k[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_l[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_m[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },   
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },  
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_n[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_o[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_p[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_q[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_r[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_s[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_t[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
{ 0,0,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_u[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_v[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_w[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,0,0,0,1,1,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
{ 0,1,1,0,1,1,1,0,1,1,0,0,0,0 },
{ 0,1,1,0,1,0,1,0,1,1,0,0,0,0 },
{ 0,1,1,0,1,0,1,0,1,1,0,0,0,0 },
{ 0,0,1,1,1,0,1,1,1,0,0,0,0,0 },
{ 0,0,1,1,1,0,1,1,1,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,1,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },   
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },  
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_x[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_y[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_z[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_tilda[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,0,0,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,0,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_exclamation[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_at[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,1,1,0,0,0,0 },
{ 0,1,0,0,1,1,0,1,1,0,1,0,0,0 },
{ 0,1,0,1,1,1,1,1,1,0,1,0,0,0 },
{ 1,0,1,1,0,0,0,1,1,0,1,0,0,0 },
{ 1,0,1,1,0,0,0,1,1,0,1,0,0,0 },
{ 1,0,1,1,0,0,0,1,1,0,1,0,0,0 },
{ 1,0,1,1,1,1,1,1,1,1,0,0,0,0 },
{ 1,0,0,1,1,0,1,1,1,0,0,0,0,0 },
{ 0,1,0,0,0,0,0,0,0,0,1,0,0,0 },
{ 0,0,1,0,0,0,0,0,0,1,0,0,0,0 },
{ 0,0,0,1,1,1,1,1,1,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_hash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_dollarsign[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 0,0,0,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,1,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,1,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_percent[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //14
{
{ 0,1,1,1,0,0,0,0,1,1,0,0,0,0 },
{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
{ 1,1,0,1,1,0,1,1,0,0,0,0,0,0 },
{ 0,1,1,1,0,0,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,1,1,1,0,0,0 },
{ 0,0,0,0,1,1,0,1,1,0,1,1,0,0 },
{ 0,0,0,0,1,1,0,1,1,0,1,1,0,0 },
{ 0,0,0,1,1,0,0,1,1,0,1,1,0,0 },
{ 0,0,0,1,1,0,0,0,1,1,1,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_raiseto[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_andsign[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,1,1,0,0,0,0,0 },
{ 1,1,0,0,1,1,1,1,1,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,1,1,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,1,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_star[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,0,1,0,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,0,1,0,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_leftbracket[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_rightbracket[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_dash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_underscore[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_plus[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_equals[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_leftcurly[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_rightcurly[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_vert[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_leftsquare[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_rightsquare[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_backslash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_forwardslash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_semicolon[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_colon[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_singlequote[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_comma[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_point[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_doublequote[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_lessthan[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_morethan[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_questionmark[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_One[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Two[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Three[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Four[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Five[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Six[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Seven[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Eight[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Nine[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },   
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Zero[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },   
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_SMALLFONT_A[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_B[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_C[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_D[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_E[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_F[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_G[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,0,0 },
 { 1,0,1,1,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_H[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },};


const byte CPLOT_SMALLFONT_I[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 1,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_J[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,1,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,1,0,0 },
 { 1,0,0,1,0,0 },
 { 0,1,1,0,0,0 },};

const byte CPLOT_SMALLFONT_K[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,1,0,0 },
 { 1,0,0,1,0,0 },
 { 1,0,1,0,0,0 },
 { 1,1,0,0,0,0 },
 { 1,1,0,0,0,0 },
 { 1,0,1,0,0,0 },
 { 1,0,0,1,0,0 },};

const byte CPLOT_SMALLFONT_L[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_M[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 1,1,0,1,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_N[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 1,1,0,0,1,0 },
 { 1,1,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,0,1,1,0 },
 { 1,0,0,1,1,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_O[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_P[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_Q[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,0,1,0,0 },
 { 0,1,1,0,1,0 },};

const byte CPLOT_SMALLFONT_R[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,0,0,0 },
 { 1,0,0,1,0,0 },
 { 1,0,0,1,0,0 },
 { 1,1,1,0,0,0 },
 { 1,0,1,0,0,0 },
 { 1,0,0,1,0,0 },
 { 1,0,0,1,0,0 },};

const byte CPLOT_SMALLFONT_S[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,0,0 },
 { 0,1,1,1,0,0 },
 { 0,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_T[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_U[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_V[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_W[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 0,1,0,1,0,0 },};

const byte CPLOT_SMALLFONT_X[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_Y[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,1,0 },
 { 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_Z[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_a[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,1,1,1,1,0 },
 { 0,0,0,0,1,0 },
 { 0,1,1,1,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_b[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_c[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_d[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,1,1,1,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_e[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,0,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_f[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },};

const byte CPLOT_SMALLFONT_g[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,1,1,0 },
 { 0,1,0,0,1,0 },
 { 0,1,1,1,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,1,1,0,0 },};

const byte CPLOT_SMALLFONT_h[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_i[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_j[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 1,0,1,0,0,0 },
 { 0,1,0,0,0,0 },};

const byte CPLOT_SMALLFONT_k[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,1,0,0,0 },
 { 1,1,0,0,0,0 },
 { 1,1,0,0,0,0 },
 { 1,0,1,1,0,0 },};

const byte CPLOT_SMALLFONT_l[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_m[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },};

const byte CPLOT_SMALLFONT_n[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_o[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,1,1,1,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_p[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 1,1,1,0,0,0 },
 { 1,0,0,1,0,0 },
 { 1,0,0,1,0,0 },
 { 1,1,1,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_q[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,1,1,1,0 },
 { 0,1,0,0,1,0 },
 { 0,1,0,0,1,0 },
 { 0,0,1,1,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_r[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,0,1,1,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,1,0,0,0,0 },};

const byte CPLOT_SMALLFONT_s[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,1,1,0 },
 { 0,1,0,0,0,0 },
 { 0,1,1,1,1,0 },
 { 0,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_t[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 1,1,1,1,1,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_u[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_v[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,0,0,0,1,0 },
 { 1,0,0,0,1,0 },
 { 0,1,0,1,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_w[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 0,1,0,1,0,0 },};

const byte CPLOT_SMALLFONT_x[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,0,0,0,1,0 },
 { 0,1,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,1,0,0 },
 { 1,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_y[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,0,0,0,1,0 },
 { 0,1,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_z[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,1,1,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,1,1,1,1,0 },};

const byte CPLOT_SMALLFONT_colon[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },};

const byte CPLOT_SMALLFONT_backslash[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,0,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,0,1 },};

const byte CPLOT_SMALLFONT_forwardslash[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,1 },
 { 0,0,0,0,1,0 },
 { 0,0,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_percent[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 1,1,0,0,1,0 },
 { 1,1,0,0,1,0 },
 { 0,0,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,1,1,0 },
 { 1,0,0,1,1,0 },};

const byte CPLOT_SMALLFONT_raiseto[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,1,0,1,0,0 },
 { 1,0,0,0,1,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_dollarsign[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
 { 1,0,1,0,1,0 },
 { 1,0,1,0,0,0 },
 { 0,1,1,1,0,0 },
 { 0,0,1,0,1,0 },
 { 1,0,1,0,1,0 },
 { 0,1,1,1,0,0 },};

const byte CPLOT_SMALLFONT_andsign[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,0,0,0 },
 { 1,0,0,1,0,0 },
 { 1,0,0,1,0,0 },
 { 0,1,1,0,0,0 },
 { 1,0,1,0,1,0 },
 { 1,0,0,1,0,0 },
 { 0,1,1,0,1,0 },};

const byte CPLOT_SMALLFONT_star[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 1,0,1,0,1,0 },
 { 0,1,1,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,1,0,0 },
 { 1,0,0,0,1,0 },
 { 0,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_leftbracket[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_rightbracket[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,1,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_leftsquare[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,0,0,0,0,0 },
 { 1,1,1,0,0,0 },};

const byte CPLOT_SMALLFONT_rightsquare[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,1,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,0,0,1,0 },
 { 0,0,1,1,1,0 },};

const byte CPLOT_SMALLFONT_dash[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,1,1,1,1,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_equals[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,1,1,1,1,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 1,1,1,1,1,0 },
 { 0,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_plus[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 1,1,1,1,1,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_semicolon[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =   
{{ 0,0,0,0,0,0 },
 { 0,1,1,0,0,0 },
 { 0,1,1,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_singlequote[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_doublequote[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 0,1,0,1,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },

 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_lessthan[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,0,0,1,0 },
 { 0,0,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,0,0,1,0 },};

const byte CPLOT_SMALLFONT_morethan[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 1,0,0,0,0,0 },
 { 0,1,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,0,1,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_comma[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,1,0,0,0,0 },
 { 1,0,0,0,0,0 },};

const byte CPLOT_SMALLFONT_point[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },};

const byte CPLOT_SMALLFONT_exclamation[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,0,0,0,0 },
 { 0,0,1,1,0,0 },
 { 0,0,1,1,0,0 },};


const byte CPLOT_SMALLFONT_vert[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },
 { 0,0,1,0,0,0 },};

const byte CPLOT_SMALLFONT_tilda[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },
 { 0,1,1,0,0,0 },
 { 1,0,1,0,1,0 },
 { 0,0,0,1,1,0 },
 { 0,0,0,0,0,0 },
 { 0,0,0,0,0,0 },};


const byte CPLOT_SMALLFONT_Zero[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,1,1,0 },
{ 1,0,1,0,1,0 },
{ 1,1,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }};

const byte CPLOT_SMALLFONT_One[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,1,0,0,0 },
{ 0,1,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,1,1,0,0 }};

const byte CPLOT_SMALLFONT_Two[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,1,1,1,1,0 }};

const byte CPLOT_SMALLFONT_Three[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }};

const byte CPLOT_SMALLFONT_Four[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,0,0,1,0,0 },
{ 0,0,1,1,0,0 },
{ 0,1,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,1,0,0 }};

const byte CPLOT_SMALLFONT_Five[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }};

const byte CPLOT_SMALLFONT_Six[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] = 
{{ 0,0,1,1,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }};

const byte CPLOT_SMALLFONT_Seven[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 1,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }};

const byte CPLOT_SMALLFONT_Eight[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }};

const byte CPLOT_SMALLFONT_Nine[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,1,1,0,0,0 }};




BOOL CPLOT_BYTE_MTX_Init( CPLOT_structByteMatrix *M )
{
  if( !M )
    return FALSE;

  M->ncols = 0;
  M->nrows = 0;
  M->data = NULL;
  
  return TRUE;
}

BOOL CPLOT_BYTE_MTX_isNull( const CPLOT_structByteMatrix *M )
{
  if( !M )
    return TRUE;

  if( M->data == NULL )
    return TRUE;

  return FALSE;
}

/// zero the entire matrix
BOOL CPLOT_BYTE_MTX_Zero( CPLOT_structByteMatrix *dst )
{
  unsigned i = 0;  
  
  if( CPLOT_BYTE_MTX_isNull( dst ) )  
    return FALSE;

  for( i = 0; i < dst->nrows; i++ )
  {    
#ifdef INTEL_IPPS    
    if( ippsZero_8u( (Ipp8u*)(dst->data[i]), dst->ncols ) != ippStsNoErr )
      return FALSE;
#else
    memset( &(dst->data[i]), 0, dst->ncols );
#endif
  }
  return TRUE;
}

BOOL CPLOT_BYTE_MTX_Free( CPLOT_structByteMatrix *M )
{
  unsigned i = 0;

  if( !M )
    return FALSE;

  if( M->data == NULL )  
  {
    M->nrows = 0;
    M->ncols = 0;
    return TRUE;
  } 

  // free the data
  for( i = 0; i < M->nrows; i++ )
  {
#ifdef INTEL_IPPS
    ippsFree( M->data[i] );
#else
    free( M->data[i] );
#endif
  }

  // free the array of pointers
  free( M->data );
  
  M->nrows = 0;
  M->ncols = 0;   
  M->data = NULL;
  
  return TRUE;
}


BOOL CPLOT_BYTE_MTX_calloc( CPLOT_structByteMatrix *M, const unsigned nrows, const unsigned ncols )
{ 
  unsigned i = 0;
  
  // invalid call
  if( nrows == 0 || ncols == 0 ) 
    return FALSE;   
  if( !M )
    return FALSE;

  // Check if the matrix is already the right size and type.
  if( M->nrows > 0 && M->ncols > 0 )
  {
    if( M->nrows == nrows && M->ncols == ncols )
    {
      // already the right size and type
      if( !CPLOT_BYTE_MTX_Zero( M ) )
        return FALSE;

      return TRUE;
    }
  }
  
  // check if we still need to deallocate memory
  if( M->data != NULL )
  {
    // free the data
    if( !CPLOT_BYTE_MTX_Free( M ) )
      return FALSE;
  }

  M->nrows = 0;
  M->ncols = ncols;

  // allocate the column array
  M->data = (byte**)malloc( nrows*sizeof(byte*) );
  if( !M->data )
    return FALSE;
  
  // for each column allocate the rows
  for( i = 0; i < nrows; i++ )
  {
#ifdef INTEL_IPPS  
    M->data[i] = ippsMalloc_8u( ncols );
    if( !(M->data[i]) )
    {
      // this is most likely to occur if allocating more memory than available
      CPLOT_BYTE_MTX_Free( M );
      return FALSE;
    }
    if( ippsZero_8u( (Ipp8u*)(M->data[i]), ncols ) != ippStsNoErr )
      return FALSE;
#else
    M->data[i] = (byte*)calloc( ncols, sizeof(byte) );    
    if( !M->data[i] )
    {
      // this is most likely to occur if allocating more memory than available
      CPLOT_BYTE_MTX_Free( M );
      return FALSE;
    }
#endif
    M->nrows++;
  }      

  return TRUE; 
}

/// fills the matrix with the given value
BOOL CPLOT_BYTE_MTX_Fill( CPLOT_structByteMatrix *dst, const byte value )
{
  unsigned i = 0;
  
  if( CPLOT_BYTE_MTX_isNull( dst ) )
    return FALSE;

  for( i = 0; i < dst->nrows; i++ )
  {
#ifdef INTEL_IPPS        
    if( ippsSet_8u( (Ipp8u)(value), (Ipp8u*)(dst->data[i]), dst->ncols ) != ippStsNoErr )
      return FALSE;
#else
    memset( dst->data[i], value, dst->ncols );
#endif
  }
  return TRUE;
}

BOOL CPLOT_PlotOptionsInit( CPLOT_structPlotOptions *Opt )
{
  if( !Opt )
    return FALSE;
  memset( Opt, 0, sizeof(CPLOT_structPlotOptions) );
  Opt->y_label_right_scale_factor = 1.0;
  Opt->RightYLabelColor = CPLOT_BLACK;
  Opt->numberOfSeries = 1;
  Opt->plotLabelOnRight = TRUE;
  Opt->endOfWarmupEpoch = -DBL_MAX;    
  Opt->PlotSize_Width_cm  = CPLOT_DEFAULT_PLOT_WIDTH_CM;  // cm
  Opt->PlotSize_Height_cm = CPLOT_DEFAULT_PLOT_HEIGHT_CM; // cm
  return TRUE;
}

BOOL CPLOT_Init( CPLOT* P )
{
  int rem = 0;
  if( !P )
    return FALSE;

  P->mIsAxesDrawn  = FALSE;
  P->mSeriesIndex = 0;
  P->mFootNoteIndex = 0;

  P->mStatsValueHeight     = 15;
  P->mYLabelAllowance      = 106;
  P->mRightYLabelAllowance = 80;
  P->mTitleAllowance       = 50;
  P->mXLabelAllowance      = 56;
  
  P->mImage.Height = CPLOT_DEFAULT_PLOT_HEIGHT_CM * CPLOT_PIXELS_PER_CM;
  P->mImage.Width  = CPLOT_DEFAULT_PLOT_WIDTH_CM  * CPLOT_PIXELS_PER_CM;

  // The width must be evely divisible by four
  rem = P->mImage.Width%4;
  P->mImage.Width += rem;


  P->mAxes.StartX  = 100;
  P->mAxes.StartY  = 40;
  P->mAxes.FinishX = 530;
  P->mAxes.FinishY = 440;
  P->mAxes.Width  = P->mAxes.FinishX - P->mAxes.StartX;
  P->mAxes.Height = P->mAxes.FinishY - P->mAxes.StartY; 
  P->mAxes.TickDashInPixels = 4;

  // pointer to special color table if any
  P->mColorTable = NULL;

  // this is the default color order
  P->mDefaultColorTable = CPLOT_DefaultColorTable;

  P->mData.xtickstart = 0.0;
  P->mData.xtickend = 0.0;
  P->mData.xticksize = 0.0;
  P->mData.ytickstart = 0.0;
  P->mData.ytickend = 0.0;
  P->mData.yticksize = 0.0;
  P->mData.RangeX = 0.0;
  P->mData.RangeY = 0.0;
  P->mData.OnePercentRangeX = 0.0;
  P->mData.OnePercentRangeY = 0.0;
  P->mData.ScaleX = 0.0;
  P->mData.ScaleY = 0.0;
  P->mData.MinX = 0.0;
  P->mData.MaxX = 0.0;
  P->mData.MinY = 0.0;
  P->mData.MaxY = 0.0;

  P->mLabelWidth = 80; //kSmallFontWidth*mStatsValueHeight;  80*8/32 must be evely divisible

  memset( &(P->mOptions), 0, sizeof(CPLOT_structPlotOptions) );
  P->mOptions.y_label_right_scale_factor = 1.0;
  P->mOptions.RightYLabelColor = CPLOT_BLACK;
  P->mOptions.numberOfSeries = 1;
  P->mOptions.plotLabelOnRight = TRUE;
  P->mOptions.endOfWarmupEpoch = -DBL_MAX;
  P->mOptions.PlotSize_Width_cm = 19;  // cm
  P->mOptions.PlotSize_Height_cm = 14; // cm

  if( !CPLOT_BYTE_MTX_Init( &(P->mPlotData) ) )
    return FALSE;
  if( !CPLOT_BYTE_MTX_calloc( &(P->mPlotData), P->mImage.Height, P->mImage.Width ) )
    return FALSE;  

  return TRUE;
}


BOOL CPLOT_SetPlottingOptions( CPLOT *P, CPLOT_structPlotOptions Options )
{
  if( !P )
    return FALSE;

  P->mOptions = Options;
  return TRUE;
}


BOOL CPLOT_DrawLine( 
  CPLOT *P,
  const int x, 
  const int y, 
  const int to_x, 
  const int to_y,
  const CPLOT_enumColor color 
  )
{
  int row    = 0,
    row_last = 0,
    halfway  = 0,
    col      = 0;

  double m = 0.0,
    b = 0.0;

  if( !P )
    return FALSE;

  if( x >= P->mImage.Width || to_x >= P->mImage.Width )
    return TRUE;
  if( y >= P->mImage.Height || to_y >= P->mImage.Height )
    return TRUE;

  if( to_x - x == 0 ) // vertical line
  {      
    if( y < to_y )
    {
      for( row=y; row<=to_y; row++ )
      {
        P->mPlotData.data[row][x] = color;
      }
    }
    else
    {
      for( row=to_y; row<=y; row++ )
      {
        P->mPlotData.data[row][x] = color;
      }
    }
    return TRUE;
  }

  if( to_x > x )
  {
    m = (double)(to_y - y) / (double)(to_x - x);
    b = y - m*x;

    col = x;
    row_last = (int)(m*col + b);      
    for( col=x; col<=to_x; col++ )
    {
      row = (int)(m*col + b);

      halfway = abs(row_last - row) / 2;
      while( abs(row_last - row) > 1 ) // must draw a vertical line
      {
        if( row_last > row )
          row_last--;
        else
          row_last++;

        // draw vertical halfway up col-1 and halfway up col
        if( abs(row_last - row) > halfway )
          P->mPlotData.data[row_last][col-1] = color;          
        else
          P->mPlotData.data[row_last][col] = color;          
      }

      P->mPlotData.data[row][col] = color;                    
      row_last = row;
    }
  }
  else
  {
    m = (double)(y - to_y) / (double)(x - to_x);
    b = y - m*x;

    col = to_x;
    row_last = (int)(m*col + b);      
    for( col=to_x; col<=x; col++ )
    {
      row = (int)(m*col + b);

      halfway = abs(row_last - row) / 2;
      while( abs(row_last - row) > 1 ) // must draw a vertical line
      {
        if( row_last > row )
          row_last--;
        else
          row_last++;

        // draw vertical halfway up col-1 and halfway up col
        if( abs(row_last - row) > halfway )
          P->mPlotData.data[row_last][col-1] = color;
        else
          P->mPlotData.data[row_last][col] = color;
      }

      P->mPlotData.data[row][col] = color;      
      row_last = row;
    }
  }
  return TRUE;
}


BOOL CPLOT_DrawDashedLine( 
  CPLOT *P,
  const int x, 
  const int y, 
  const int to_x, 
  const int to_y,
  const int kDashSize,
  const CPLOT_enumColor color )
{
  int row    = 0,
    row_last = 0,
    halfway  = 0,
    col      = 0,
    dash     = 0;

  double m = 0.0,
    b = 0.0;

  if( !P )
    return FALSE;

  if( x >= P->mImage.Width || to_x >= P->mImage.Width )
    return TRUE;
  if( y >= P->mImage.Height || to_y >= P->mImage.Height )
    return TRUE;


  // y = mx + b
  if( to_x - x == 0 ) // m = 0
  {
    for( row=y; row<=to_y; row++ )
    {
      if( dash < kDashSize )
        P->mPlotData.data[row][x] = color;

      dash++;
      if( dash == kDashSize*2 )
        dash = 0;
    }
    return TRUE;
  }

  if( to_x > x )
  {
    dash = 0;
    m = (double)(to_y - y) / (double)(to_x - x);
    b = y - m*x;

    col = x;
    row_last = (int)(m*col + b);      
    for( col=x; col<=to_x; col++ )
    {
      row = (int)(m*col + b);

      halfway = abs(row_last - row) / 2;
      while( abs(row_last - row) > 1 ) // must draw a vertical line
      {
        if( row_last > row )
          row_last--;
        else
          row_last++;

        // draw vertical halfway up col-1 and halfway up col
        if( abs(row_last - row) > halfway )
        {
          if( dash < kDashSize )
            P->mPlotData.data[row_last][col-1] = color;
        }
        else
        {
          if( dash < kDashSize )
            P->mPlotData.data[row_last][col] = color;            
        }

        dash++;
        if( dash == kDashSize*2 )
          dash = 0;

      }

      if( dash < kDashSize )
        P->mPlotData.data[row][col] = color;

      dash++;
      if( dash == kDashSize*2 )
        dash = 0;         
    }
  }
  else
  {
    dash = 0;
    m = (double)(y - to_y) / (double)(x - to_x);
    b = y - m*x;

    col = to_x;
    row_last = (int)(m*col + b);      
    for( col=to_x; col<=x; col++ )
    {         
      row = (int)(m*col + b);

      halfway = abs(row_last - row) / 2;
      while( abs(row_last - row) > 1 ) // must draw a vertical line
      {
        if( row_last > row )
          row_last--;
        else
          row_last++;

        // draw vertical halfway up col-1 and halfway up col
        if( abs(row_last - row) > halfway )
        {
          if( dash < kDashSize )
            P->mPlotData.data[row_last][col-1] = color;            
        }
        else
        {
          if( dash < kDashSize )
            P->mPlotData.data[row_last][col] = color;                        
        }
        dash++;
        if( dash == kDashSize*2 )
          dash = 0;
      }

      if( dash < kDashSize )
        P->mPlotData.data[row][col] = color;                                

      dash++;
      if( dash == kDashSize*2 )
        dash = 0;


      row_last = row;
    }
  }

  return TRUE;
}




int CPLOT_DrawSmallLetter( 
  CPLOT *P,
  const char Letter, 
  const int x, 
  const int y,                                  
  BOOL isRotatedLeft,
  const CPLOT_enumColor color 
  )
{
  const int klH = CPLOT_SMALLFONT_HGT;   // letter height
  const int klW = CPLOT_SMALLFONT_WIDTH; // letter width

  int row = 0;
  int col = 0;

  byte rotatedleft[CPLOT_SMALLFONT_WIDTH][CPLOT_SMALLFONT_HGT];
  byte temp[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH];

  if( !P )
    return FALSE;

  if( y < klH )
    return 0;

  if( x + klW >= P->mImage.Width )
    return 0;

  memset( &rotatedleft, 0, CPLOT_SMALLFONT_WIDTH*CPLOT_SMALLFONT_HGT );
  memset( &temp, 0, CPLOT_SMALLFONT_WIDTH*CPLOT_SMALLFONT_HGT );

  switch( Letter )
  {
  case 'A':  memcpy( &temp, CPLOT_SMALLFONT_A, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'B':  memcpy( &temp, CPLOT_SMALLFONT_B, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'C':  memcpy( &temp, CPLOT_SMALLFONT_C, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'D':  memcpy( &temp, CPLOT_SMALLFONT_D, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'E':  memcpy( &temp, CPLOT_SMALLFONT_E, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'F':  memcpy( &temp, CPLOT_SMALLFONT_F, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'G':  memcpy( &temp, CPLOT_SMALLFONT_G, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'H':  memcpy( &temp, CPLOT_SMALLFONT_H, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'I':  memcpy( &temp, CPLOT_SMALLFONT_I, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'J':  memcpy( &temp, CPLOT_SMALLFONT_J, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'K':  memcpy( &temp, CPLOT_SMALLFONT_K, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'L':  memcpy( &temp, CPLOT_SMALLFONT_L, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'M':  memcpy( &temp, CPLOT_SMALLFONT_M, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'N':  memcpy( &temp, CPLOT_SMALLFONT_N, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'O':  memcpy( &temp, CPLOT_SMALLFONT_O, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'P':  memcpy( &temp, CPLOT_SMALLFONT_P, CPLOT_SMALLFONT_NBYTES ); break;        
  case 'Q':  memcpy( &temp, CPLOT_SMALLFONT_Q, CPLOT_SMALLFONT_NBYTES ); break;
  case 'R':  memcpy( &temp, CPLOT_SMALLFONT_R, CPLOT_SMALLFONT_NBYTES ); break;
  case 'S':  memcpy( &temp, CPLOT_SMALLFONT_S, CPLOT_SMALLFONT_NBYTES ); break;
  case 'T':  memcpy( &temp, CPLOT_SMALLFONT_T, CPLOT_SMALLFONT_NBYTES ); break;
  case 'U':  memcpy( &temp, CPLOT_SMALLFONT_U, CPLOT_SMALLFONT_NBYTES ); break;
  case 'V':  memcpy( &temp, CPLOT_SMALLFONT_V, CPLOT_SMALLFONT_NBYTES ); break;
  case 'W':  memcpy( &temp, CPLOT_SMALLFONT_W, CPLOT_SMALLFONT_NBYTES ); break;
  case 'X':  memcpy( &temp, CPLOT_SMALLFONT_X, CPLOT_SMALLFONT_NBYTES ); break;
  case 'Y':  memcpy( &temp, CPLOT_SMALLFONT_Y, CPLOT_SMALLFONT_NBYTES ); break;
  case 'Z':  memcpy( &temp, CPLOT_SMALLFONT_Z, CPLOT_SMALLFONT_NBYTES ); break;


  case 'a':  memcpy( &temp, CPLOT_SMALLFONT_a, CPLOT_SMALLFONT_NBYTES ); break;
  case 'b':  memcpy( &temp, CPLOT_SMALLFONT_b, CPLOT_SMALLFONT_NBYTES ); break;
  case 'c':  memcpy( &temp, CPLOT_SMALLFONT_c, CPLOT_SMALLFONT_NBYTES ); break;
  case 'd':  memcpy( &temp, CPLOT_SMALLFONT_d, CPLOT_SMALLFONT_NBYTES ); break;
  case 'e':  memcpy( &temp, CPLOT_SMALLFONT_e, CPLOT_SMALLFONT_NBYTES ); break;
  case 'f':  memcpy( &temp, CPLOT_SMALLFONT_f, CPLOT_SMALLFONT_NBYTES ); break;
  case 'g':  memcpy( &temp, CPLOT_SMALLFONT_g, CPLOT_SMALLFONT_NBYTES ); break;
  case 'h':  memcpy( &temp, CPLOT_SMALLFONT_h, CPLOT_SMALLFONT_NBYTES ); break;
  case 'i':  memcpy( &temp, CPLOT_SMALLFONT_i, CPLOT_SMALLFONT_NBYTES ); break;
  case 'j':  memcpy( &temp, CPLOT_SMALLFONT_j, CPLOT_SMALLFONT_NBYTES ); break;
  case 'k':  memcpy( &temp, CPLOT_SMALLFONT_k, CPLOT_SMALLFONT_NBYTES ); break;
  case 'l':  memcpy( &temp, CPLOT_SMALLFONT_l, CPLOT_SMALLFONT_NBYTES ); break;
  case 'm':  memcpy( &temp, CPLOT_SMALLFONT_m, CPLOT_SMALLFONT_NBYTES ); break;
  case 'n':  memcpy( &temp, CPLOT_SMALLFONT_n, CPLOT_SMALLFONT_NBYTES ); break;
  case 'o':  memcpy( &temp, CPLOT_SMALLFONT_o, CPLOT_SMALLFONT_NBYTES ); break;
  case 'p':  memcpy( &temp, CPLOT_SMALLFONT_p, CPLOT_SMALLFONT_NBYTES ); break;
  case 'q':  memcpy( &temp, CPLOT_SMALLFONT_q, CPLOT_SMALLFONT_NBYTES ); break;
  case 'r':  memcpy( &temp, CPLOT_SMALLFONT_r, CPLOT_SMALLFONT_NBYTES ); break;
  case 's':  memcpy( &temp, CPLOT_SMALLFONT_s, CPLOT_SMALLFONT_NBYTES ); break;
  case 't':  memcpy( &temp, CPLOT_SMALLFONT_t, CPLOT_SMALLFONT_NBYTES ); break;
  case 'u':  memcpy( &temp, CPLOT_SMALLFONT_u, CPLOT_SMALLFONT_NBYTES ); break;
  case 'v':  memcpy( &temp, CPLOT_SMALLFONT_v, CPLOT_SMALLFONT_NBYTES ); break;
  case 'w':  memcpy( &temp, CPLOT_SMALLFONT_w, CPLOT_SMALLFONT_NBYTES ); break;
  case 'x':  memcpy( &temp, CPLOT_SMALLFONT_x, CPLOT_SMALLFONT_NBYTES ); break;
  case 'y':  memcpy( &temp, CPLOT_SMALLFONT_y, CPLOT_SMALLFONT_NBYTES ); break;
  case 'z':  memcpy( &temp, CPLOT_SMALLFONT_z, CPLOT_SMALLFONT_NBYTES ); break;

  case '~':  memcpy( &temp, CPLOT_SMALLFONT_tilda, CPLOT_SMALLFONT_NBYTES ); break;
  case '!':  memcpy( &temp, CPLOT_SMALLFONT_exclamation, CPLOT_SMALLFONT_NBYTES ); break;        
  // case '@':  memcpy( &temp, CPLOT_SMALLFONT_at, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add
  //case '#':  memcpy( &temp, CPLOT_SMALLFONT_hash, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
  case '$':  memcpy( &temp, CPLOT_SMALLFONT_dollarsign, CPLOT_SMALLFONT_NBYTES ); break;
  case '%':  memcpy( &temp, CPLOT_SMALLFONT_percent, CPLOT_SMALLFONT_NBYTES ); break;
  case '^':  memcpy( &temp, CPLOT_SMALLFONT_raiseto, CPLOT_SMALLFONT_NBYTES ); break;
  case '&':  memcpy( &temp, CPLOT_SMALLFONT_andsign, CPLOT_SMALLFONT_NBYTES ); break;
  case '*':  memcpy( &temp, CPLOT_SMALLFONT_star, CPLOT_SMALLFONT_NBYTES ); break;
  case '(':  memcpy( &temp, CPLOT_SMALLFONT_leftbracket, CPLOT_SMALLFONT_NBYTES ); break;
  case ')':  memcpy( &temp, CPLOT_SMALLFONT_rightbracket, CPLOT_SMALLFONT_NBYTES ); break;
  case '-':  memcpy( &temp, CPLOT_SMALLFONT_dash, CPLOT_SMALLFONT_NBYTES ); break;
  // case '_':  memcpy( &temp, CPLOT_SMALLFONT_underscore, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
  case '+':  memcpy( &temp, CPLOT_SMALLFONT_plus, CPLOT_SMALLFONT_NBYTES ); break;
  case '=':  memcpy( &temp, CPLOT_SMALLFONT_equals, CPLOT_SMALLFONT_NBYTES ); break;
  // case '{':  memcpy( &temp, CPLOT_SMALLFONT_leftcurly, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
  // case '}':  memcpy( &temp, CPLOT_SMALLFONT_rightcurly, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
  case '|':  memcpy( &temp, CPLOT_SMALLFONT_vert, CPLOT_SMALLFONT_NBYTES ); break;
  case '[':  memcpy( &temp, CPLOT_SMALLFONT_leftsquare, CPLOT_SMALLFONT_NBYTES ); break;
  case ']':  memcpy( &temp, CPLOT_SMALLFONT_rightsquare, CPLOT_SMALLFONT_NBYTES ); break;
  case '\\': memcpy( &temp, CPLOT_SMALLFONT_backslash, CPLOT_SMALLFONT_NBYTES ); break;
  case '/':  memcpy( &temp, CPLOT_SMALLFONT_forwardslash, CPLOT_SMALLFONT_NBYTES ); break;
  case ';':  memcpy( &temp, CPLOT_SMALLFONT_semicolon, CPLOT_SMALLFONT_NBYTES ); break;
  case ':':  memcpy( &temp, CPLOT_SMALLFONT_colon, CPLOT_SMALLFONT_NBYTES ); break;
  case '\'': memcpy( &temp, CPLOT_SMALLFONT_singlequote, CPLOT_SMALLFONT_NBYTES ); break;
  case ',':  memcpy( &temp, CPLOT_SMALLFONT_comma, CPLOT_SMALLFONT_NBYTES ); break;
  case '.':  memcpy( &temp, CPLOT_SMALLFONT_point, CPLOT_SMALLFONT_NBYTES ); break;
  case '"':  memcpy( &temp, CPLOT_SMALLFONT_doublequote, CPLOT_SMALLFONT_NBYTES ); break;
  case '<':  memcpy( &temp, CPLOT_SMALLFONT_lessthan, CPLOT_SMALLFONT_NBYTES ); break;
  case '>':  memcpy( &temp, CPLOT_SMALLFONT_morethan, CPLOT_SMALLFONT_NBYTES ); break;
  // case '?':  memcpy( &temp, CPLOT_SMALLFONT_questionmark, CPLOT_SMALLFONT_NBYTES ); break;// GDM_TODO - add 

  case '1':  memcpy( &temp, CPLOT_SMALLFONT_One, CPLOT_SMALLFONT_NBYTES ); break;
  case '2':  memcpy( &temp, CPLOT_SMALLFONT_Two, CPLOT_SMALLFONT_NBYTES ); break;
  case '3':  memcpy( &temp, CPLOT_SMALLFONT_Three, CPLOT_SMALLFONT_NBYTES ); break;
  case '4':  memcpy( &temp, CPLOT_SMALLFONT_Four, CPLOT_SMALLFONT_NBYTES ); break;
  case '5':  memcpy( &temp, CPLOT_SMALLFONT_Five, CPLOT_SMALLFONT_NBYTES ); break;
  case '6':  memcpy( &temp, CPLOT_SMALLFONT_Six, CPLOT_SMALLFONT_NBYTES ); break;
  case '7':  memcpy( &temp, CPLOT_SMALLFONT_Seven, CPLOT_SMALLFONT_NBYTES ); break;
  case '8':  memcpy( &temp, CPLOT_SMALLFONT_Eight, CPLOT_SMALLFONT_NBYTES ); break;
  case '9':  memcpy( &temp, CPLOT_SMALLFONT_Nine, CPLOT_SMALLFONT_NBYTES ); break;
  case '0':  memcpy( &temp, CPLOT_SMALLFONT_Zero, CPLOT_SMALLFONT_NBYTES ); break;

  default: break;
  }


  if( isRotatedLeft )
  {  
    for( row = 0; row < klH; row++ )
    {      
      for( col = 0; col < klW; col++ )
      {  
        rotatedleft[5-col][row] = temp[row][col];
      }      
    }
  }

  // plot the letters
  if( isRotatedLeft )
  {
    for( row = 0; row < klW; row++ )
    {
      for( col = 0; col < klH; col++ )
      {  
        if( rotatedleft[row][col] )
          P->mPlotData.data[y-row][x+col] = rotatedleft[row][col] * color;         
      }         
    }      
  }
  else
  {
    for( row = 0; row < klH; row++ )
    {
      for( col = 0; col < klW; col++ )
      {  
        if( temp[row][col] )
          P->mPlotData.data[y-row][x+col] = temp[row][col] * color;          
      }
    }      
  }
  return klW;
}






int CPLOT_DrawLargeLetter( 
  CPLOT *P,
  const char Letter, 
  const int x, 
  const int y,
  BOOL isRotatedLeft,
  const CPLOT_enumColor color 
  )
{
  int row = 0;
  int col = 0;
  int numCols = 0;
  char letter = Letter;
  const int kSize = CPLOT_LARGEFONT;

  byte temp[CPLOT_LARGEFONT][CPLOT_LARGEFONT];
  byte rotatedleft[CPLOT_LARGEFONT][CPLOT_LARGEFONT];

  if( !P )
    return FALSE;

  memset( &temp, 0, CPLOT_LARGEFONT*CPLOT_LARGEFONT );
  memset( &rotatedleft, 0, CPLOT_LARGEFONT*CPLOT_LARGEFONT );
  
  switch( letter )
  {
  case 'A':   numCols = 11; break;
  case 'B':   numCols = 11; break;
  case 'C':   numCols = 11; break;
  case 'D':   numCols = 11; break;
  case 'E':   numCols = 11; break;
  case 'F':   numCols = 11; break;
  case 'G':   numCols = 11; break;
  case 'H':   numCols = 11; break;
  case 'I':   numCols =  3; break;   
  case 'J':   numCols =  9; break;
  case 'K':   numCols = 11; break;
  case 'L':   numCols =  9; break;
  case 'M':   numCols = 13; break;
  case 'N':   numCols = 11; break;
  case 'O':   numCols = 12; break;
  case 'P':   numCols = 10; break;
  case 'Q':   numCols = 12; break;
  case 'R':   numCols = 11; break;
  case 'S':   numCols = 10; break;   
  case 'T':   numCols = 10; break;
  case 'U':   numCols = 10; break;
  case 'V':   numCols =  9; break;
  case 'W':   numCols = 14; break;
  case 'X':   numCols = 10; break;
  case 'Y':   numCols =  9; break;
  case 'Z':   numCols =  9; break;

  case 'a':   numCols =  8; break;
  case 'b':   numCols =  9; break;
  case 'c':   numCols =  9; break;   
  case 'd':   numCols =  9; break;
  case 'e':   numCols =  9; break;
  case 'f':   numCols =  7; break;
  case 'g':   numCols =  9; break;
  case 'h':   numCols =  9; break;
  case 'i':   numCols =  4; break;
  case 'j':   numCols =  6; break;
  case 'k':   numCols =  8; break;
  case 'l':   numCols =  4; break;
  case 'm':   numCols = 12; break;   
  case 'n':   numCols =  9; break;
  case 'o':   numCols =  9; break;
  case 'p':   numCols =  9; break;
  case 'q':   numCols =  9; break;
  case 'r':   numCols =  6; break;
  case 's':   numCols =  7; break;
  case 't':   numCols =  6; break;
  case 'u':   numCols =  9; break;
  case 'v':   numCols =  8; break;
  case 'w':   numCols = 12; break;   
  case 'x':   numCols =  7; break;
  case 'y':   numCols =  8; break;
  case 'z':   numCols =  8; break;

  case '~':   numCols = 10; break;
  case '!':   numCols =  4; break;
  case '@':   numCols = 12; break;
  case '#':   numCols =  9; break;
  case '$':   numCols = 10; break;
  case '%':   numCols = 14; break;
  case '^':   numCols = 10; break;
  case '&':   numCols = 11; break;
  case '*':   numCols =  8; break;
  case '(':   numCols =  5; break;
  case ')':   numCols =  5; break;
  case '-':   numCols =  5; break;
  case '_':   numCols =  9; break;
  case '+':   numCols = 10; break;
  case '=':   numCols = 10; break;   
  case '{':   numCols =  6; break;
  case '}':   numCols =  6; break;   
  case '|':   numCols =  5; break;
  case '[':   numCols =  5; break;
  case ']':   numCols =  5; break;
  case '\\':  numCols =  6; break;
  case '/':   numCols =  6; break;   
  case ';':   numCols =  4; break;
  case ':':   numCols =  4; break;   
  case '\'':  numCols =  4; break;
  case ',':   numCols =  4; break;
  case '.':   numCols =  4; break;   
  case '"':   numCols =  8; break;
  case '<':   numCols =  9; break;
  case '>':   numCols =  9; break;
  case '?':   numCols =  9; break;

  case '1':   numCols =  7; break;
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
  case '0':   numCols =  8; break;                  

  case -1:  numCols =  12; break;
  
  default: numCols = 5; break;
  }

  
  switch( letter )
  {
  case 'A':  memcpy( &temp, CPLOT_LARGEFONT_A, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'B':  memcpy( &temp, CPLOT_LARGEFONT_B, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'C':  memcpy( &temp, CPLOT_LARGEFONT_C, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'D':  memcpy( &temp, CPLOT_LARGEFONT_D, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'E':  memcpy( &temp, CPLOT_LARGEFONT_E, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'F':  memcpy( &temp, CPLOT_LARGEFONT_F, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'G':  memcpy( &temp, CPLOT_LARGEFONT_G, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'H':  memcpy( &temp, CPLOT_LARGEFONT_H, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'I':  memcpy( &temp, CPLOT_LARGEFONT_I, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'J':  memcpy( &temp, CPLOT_LARGEFONT_J, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'K':  memcpy( &temp, CPLOT_LARGEFONT_K, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'L':  memcpy( &temp, CPLOT_LARGEFONT_L, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'M':  memcpy( &temp, CPLOT_LARGEFONT_M, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'N':  memcpy( &temp, CPLOT_LARGEFONT_N, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'O':  memcpy( &temp, CPLOT_LARGEFONT_O, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'P':  memcpy( &temp, CPLOT_LARGEFONT_P, CPLOT_LARGEFONT_NBYTES ); break;        
  case 'Q':  memcpy( &temp, CPLOT_LARGEFONT_Q, CPLOT_LARGEFONT_NBYTES ); break;
  case 'R':  memcpy( &temp, CPLOT_LARGEFONT_R, CPLOT_LARGEFONT_NBYTES ); break;
  case 'S':  memcpy( &temp, CPLOT_LARGEFONT_S, CPLOT_LARGEFONT_NBYTES ); break;
  case 'T':  memcpy( &temp, CPLOT_LARGEFONT_T, CPLOT_LARGEFONT_NBYTES ); break;
  case 'U':  memcpy( &temp, CPLOT_LARGEFONT_U, CPLOT_LARGEFONT_NBYTES ); break;
  case 'V':  memcpy( &temp, CPLOT_LARGEFONT_V, CPLOT_LARGEFONT_NBYTES ); break;
  case 'W':  memcpy( &temp, CPLOT_LARGEFONT_W, CPLOT_LARGEFONT_NBYTES ); break;
  case 'X':  memcpy( &temp, CPLOT_LARGEFONT_X, CPLOT_LARGEFONT_NBYTES ); break;
  case 'Y':  memcpy( &temp, CPLOT_LARGEFONT_Y, CPLOT_LARGEFONT_NBYTES ); break;
  case 'Z':  memcpy( &temp, CPLOT_LARGEFONT_Z, CPLOT_LARGEFONT_NBYTES ); break;


  case 'a':  memcpy( &temp, CPLOT_LARGEFONT_a, CPLOT_LARGEFONT_NBYTES ); break;
  case 'b':  memcpy( &temp, CPLOT_LARGEFONT_b, CPLOT_LARGEFONT_NBYTES ); break;
  case 'c':  memcpy( &temp, CPLOT_LARGEFONT_c, CPLOT_LARGEFONT_NBYTES ); break;
  case 'd':  memcpy( &temp, CPLOT_LARGEFONT_d, CPLOT_LARGEFONT_NBYTES ); break;
  case 'e':  memcpy( &temp, CPLOT_LARGEFONT_e, CPLOT_LARGEFONT_NBYTES ); break;
  case 'f':  memcpy( &temp, CPLOT_LARGEFONT_f, CPLOT_LARGEFONT_NBYTES ); break;
  case 'g':  memcpy( &temp, CPLOT_LARGEFONT_g, CPLOT_LARGEFONT_NBYTES ); break;
  case 'h':  memcpy( &temp, CPLOT_LARGEFONT_h, CPLOT_LARGEFONT_NBYTES ); break;
  case 'i':  memcpy( &temp, CPLOT_LARGEFONT_i, CPLOT_LARGEFONT_NBYTES ); break;
  case 'j':  memcpy( &temp, CPLOT_LARGEFONT_j, CPLOT_LARGEFONT_NBYTES ); break;
  case 'k':  memcpy( &temp, CPLOT_LARGEFONT_k, CPLOT_LARGEFONT_NBYTES ); break;
  case 'l':  memcpy( &temp, CPLOT_LARGEFONT_l, CPLOT_LARGEFONT_NBYTES ); break;
  case 'm':  memcpy( &temp, CPLOT_LARGEFONT_m, CPLOT_LARGEFONT_NBYTES ); break;
  case 'n':  memcpy( &temp, CPLOT_LARGEFONT_n, CPLOT_LARGEFONT_NBYTES ); break;
  case 'o':  memcpy( &temp, CPLOT_LARGEFONT_o, CPLOT_LARGEFONT_NBYTES ); break;
  case 'p':  memcpy( &temp, CPLOT_LARGEFONT_p, CPLOT_LARGEFONT_NBYTES ); break;
  case 'q':  memcpy( &temp, CPLOT_LARGEFONT_q, CPLOT_LARGEFONT_NBYTES ); break;
  case 'r':  memcpy( &temp, CPLOT_LARGEFONT_r, CPLOT_LARGEFONT_NBYTES ); break;
  case 's':  memcpy( &temp, CPLOT_LARGEFONT_s, CPLOT_LARGEFONT_NBYTES ); break;
  case 't':  memcpy( &temp, CPLOT_LARGEFONT_t, CPLOT_LARGEFONT_NBYTES ); break;
  case 'u':  memcpy( &temp, CPLOT_LARGEFONT_u, CPLOT_LARGEFONT_NBYTES ); break;
  case 'v':  memcpy( &temp, CPLOT_LARGEFONT_v, CPLOT_LARGEFONT_NBYTES ); break;
  case 'w':  memcpy( &temp, CPLOT_LARGEFONT_w, CPLOT_LARGEFONT_NBYTES ); break;
  case 'x':  memcpy( &temp, CPLOT_LARGEFONT_x, CPLOT_LARGEFONT_NBYTES ); break;
  case 'y':  memcpy( &temp, CPLOT_LARGEFONT_y, CPLOT_LARGEFONT_NBYTES ); break;
  case 'z':  memcpy( &temp, CPLOT_LARGEFONT_z, CPLOT_LARGEFONT_NBYTES ); break;

  case '~':  memcpy( &temp, CPLOT_LARGEFONT_tilda, CPLOT_LARGEFONT_NBYTES ); break;
  case '!':  memcpy( &temp, CPLOT_LARGEFONT_exclamation, CPLOT_LARGEFONT_NBYTES ); break;        
  case '@':  memcpy( &temp, CPLOT_LARGEFONT_at, CPLOT_LARGEFONT_NBYTES ); break;
  case '#':  memcpy( &temp, CPLOT_LARGEFONT_hash, CPLOT_LARGEFONT_NBYTES ); break;
  case '$':  memcpy( &temp, CPLOT_LARGEFONT_dollarsign, CPLOT_LARGEFONT_NBYTES ); break;
  case '%':  memcpy( &temp, CPLOT_LARGEFONT_percent, CPLOT_LARGEFONT_NBYTES ); break;
  case '^':  memcpy( &temp, CPLOT_LARGEFONT_raiseto, CPLOT_LARGEFONT_NBYTES ); break;
  case '&':  memcpy( &temp, CPLOT_LARGEFONT_andsign, CPLOT_LARGEFONT_NBYTES ); break;
  case '*':  memcpy( &temp, CPLOT_LARGEFONT_star, CPLOT_LARGEFONT_NBYTES ); break;
  case '(':  memcpy( &temp, CPLOT_LARGEFONT_leftbracket, CPLOT_LARGEFONT_NBYTES ); break;
  case ')':  memcpy( &temp, CPLOT_LARGEFONT_rightbracket, CPLOT_LARGEFONT_NBYTES ); break;
  case '-':  memcpy( &temp, CPLOT_LARGEFONT_dash, CPLOT_LARGEFONT_NBYTES ); break;
  case '_':  memcpy( &temp, CPLOT_LARGEFONT_underscore, CPLOT_LARGEFONT_NBYTES ); break;
  case '+':  memcpy( &temp, CPLOT_LARGEFONT_plus, CPLOT_LARGEFONT_NBYTES ); break;
  case '=':  memcpy( &temp, CPLOT_LARGEFONT_equals, CPLOT_LARGEFONT_NBYTES ); break;
  case '{':  memcpy( &temp, CPLOT_LARGEFONT_leftcurly, CPLOT_LARGEFONT_NBYTES ); break;
  case '}':  memcpy( &temp, CPLOT_LARGEFONT_rightcurly, CPLOT_LARGEFONT_NBYTES ); break;
  case '|':  memcpy( &temp, CPLOT_LARGEFONT_vert, CPLOT_LARGEFONT_NBYTES ); break;
  case '[':  memcpy( &temp, CPLOT_LARGEFONT_leftsquare, CPLOT_LARGEFONT_NBYTES ); break;
  case ']':  memcpy( &temp, CPLOT_LARGEFONT_rightsquare, CPLOT_LARGEFONT_NBYTES ); break;
  case '\\': memcpy( &temp, CPLOT_LARGEFONT_backslash, CPLOT_LARGEFONT_NBYTES ); break;
  case '/':  memcpy( &temp, CPLOT_LARGEFONT_forwardslash, CPLOT_LARGEFONT_NBYTES ); break;
  case ';':  memcpy( &temp, CPLOT_LARGEFONT_semicolon, CPLOT_LARGEFONT_NBYTES ); break;
  case ':':  memcpy( &temp, CPLOT_LARGEFONT_colon, CPLOT_LARGEFONT_NBYTES ); break;
  case '\'': memcpy( &temp, CPLOT_LARGEFONT_singlequote, CPLOT_LARGEFONT_NBYTES ); break;
  case ',':  memcpy( &temp, CPLOT_LARGEFONT_comma, CPLOT_LARGEFONT_NBYTES ); break;
  case '.':  memcpy( &temp, CPLOT_LARGEFONT_point, CPLOT_LARGEFONT_NBYTES ); break;
  case '"':  memcpy( &temp, CPLOT_LARGEFONT_doublequote, CPLOT_LARGEFONT_NBYTES ); break;
  case '<':  memcpy( &temp, CPLOT_LARGEFONT_lessthan, CPLOT_LARGEFONT_NBYTES ); break;
  case '>':  memcpy( &temp, CPLOT_LARGEFONT_morethan, CPLOT_LARGEFONT_NBYTES ); break;
  case '?':  memcpy( &temp, CPLOT_LARGEFONT_questionmark, CPLOT_LARGEFONT_NBYTES ); break;

  case '1':  memcpy( &temp, CPLOT_LARGEFONT_One, CPLOT_LARGEFONT_NBYTES ); break;
  case '2':  memcpy( &temp, CPLOT_LARGEFONT_Two, CPLOT_LARGEFONT_NBYTES ); break;
  case '3':  memcpy( &temp, CPLOT_LARGEFONT_Three, CPLOT_LARGEFONT_NBYTES ); break;
  case '4':  memcpy( &temp, CPLOT_LARGEFONT_Four, CPLOT_LARGEFONT_NBYTES ); break;
  case '5':  memcpy( &temp, CPLOT_LARGEFONT_Five, CPLOT_LARGEFONT_NBYTES ); break;
  case '6':  memcpy( &temp, CPLOT_LARGEFONT_Six, CPLOT_LARGEFONT_NBYTES ); break;
  case '7':  memcpy( &temp, CPLOT_LARGEFONT_Seven, CPLOT_LARGEFONT_NBYTES ); break;
  case '8':  memcpy( &temp, CPLOT_LARGEFONT_Eight, CPLOT_LARGEFONT_NBYTES ); break;
  case '9':  memcpy( &temp, CPLOT_LARGEFONT_Nine, CPLOT_LARGEFONT_NBYTES ); break;
  case '0':  memcpy( &temp, CPLOT_LARGEFONT_Zero, CPLOT_LARGEFONT_NBYTES ); break;

  case -1:  memcpy( &temp, CPLOT_LARGEFONT_sigma, CPLOT_LARGEFONT_NBYTES ); break;

  default: break;
  }

  if( isRotatedLeft )
  {
    for( row = 0; row < kSize; row++ )
    {      
      for( col = 0; col < kSize; col++ )
      {  
        rotatedleft[kSize - row - 1][col] = temp[col][row];
      }      
    }
  }

  // plot the letters
  if( isRotatedLeft )
  {
    if( y < kSize )
      return 0;

    if( x + kSize >= P->mImage.Width )
      return 0;

    for( row = kSize - numCols; row < kSize; row++ )
    {
      for( col = 0; col < kSize; col++ )
      {  
        if( rotatedleft[row][col] )
          P->mPlotData.data[y-row][x+col] = (rotatedleft[row][col]) * color;            
      }         
    }      
  }
  else
  {
    if( y < kSize )
      return 0;

    if( x + numCols >= P->mImage.Width )
      return 0;

    for( row = 0; row < kSize; row++ )
    {
      for( col = 0; col < numCols; col++ )
      {            
        if( temp[row][col] )
          P->mPlotData.data[y-row][x+col] = (temp[row][col]) * color;
      }
    }
  }

  return numCols;
}

BOOL CPLOT_DrawString( 
  CPLOT *P,
  const char* str, 
  const int left, 
  const int top,
  const BOOL useLargeFont,
  const BOOL isRotatedLeft,
  const CPLOT_enumColor color 
  )
{ 
  int length;

  int offset = 0,
    i      = 0,
    letterWidth = 0;

  if( str == NULL )
    return TRUE; // nothing to draw

  length = (int)strlen(str);

  if( !P )
    return FALSE;
  if( !str )
    return FALSE;

  if( left >= P->mImage.Width )
    return TRUE;
  if( top >= P->mImage.Height )
    return TRUE;

  if( strstr( str, "\\sigma" ) )
  {
    letterWidth = CPLOT_DrawLargeLetter( P, -1, left, top + offset, isRotatedLeft, color );  // GDM_HACK - a hack for now.
  }
  else
  {
    for( i = 0; i < length; i++ )      
    {
      if( isRotatedLeft )
      {
        if( top + offset > P->mImage.Height )
          break;

        if( useLargeFont )
          letterWidth = CPLOT_DrawLargeLetter( P, str[i], left, top + offset, isRotatedLeft, color );          
        else
          letterWidth = CPLOT_DrawSmallLetter( P, str[i], left, top + offset, isRotatedLeft, color );
      }
      else
      {
        if( left + offset > P->mImage.Width )
          break;

        if( useLargeFont )
          letterWidth = CPLOT_DrawLargeLetter( P, str[i], left + offset, top, isRotatedLeft, color );
        else
          letterWidth = CPLOT_DrawSmallLetter( P, str[i], left + offset, top, isRotatedLeft, color );

      }
      offset += letterWidth;      
    }
  }
  return TRUE;
}




BOOL CPLOT_DrawValue( 
  CPLOT *P,
  const BOOL leftalign,
  double value, 
  const int left, 
  const int top,
  const CPLOT_enumColor color 
  )
{
  const int kTextWidth = 6*13;
  char ValueBuffer[48];
  size_t length = 0;

  if( !P )
    return FALSE;

  ValueBuffer[0] = '\0';

  if( leftalign )
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    sprintf_s( ValueBuffer, 48, "%-13.7g", value );
#else
    sprintf( ValueBuffer, "%-13.7g", value );
#endif
  }
  else
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    sprintf_s( ValueBuffer, 48, "%13.7g", value );
#else
    sprintf( ValueBuffer, "%13.7g", value );
#endif
  }

  
  if( (left + kTextWidth) >= P->mImage.Width )
    return TRUE;
  if( top >= P->mImage.Height )
    return TRUE;

  length = strlen(ValueBuffer);

  if( !CPLOT_DrawString( P, ValueBuffer, left, top, TRUE, FALSE, color ) )
    return FALSE;

  return TRUE;
}



BOOL CPLOT_ResizePlot( CPLOT *P  )
{
  //---------------------------mImage.Width--------------------------------//
  //|               |                                |                    |
  //|               mTitleAllowance                  |                    |
  //|               |                                |                    |
  //|               |--------------------------------+                    |
  //|<-mYLabelAll.->|                                |<-mRightYLabelAll.->|
  //|               |                                |                    |
  //|               |                                |                    |
  //|               |                                |                    |
  //mImage.Height   |                              mAxes.Height           |
  //|               |                                |                    |
  //|               |                                |                    |
  //|               |                                |                    |
  //|               +--------mAxes.Width-------------+                    |
  //|               |                                |                    |
  //|               mXLabelAllowance                 |                    |
  //|               |                                |                    |
  //|               |                                |                    |
  //---------------------------mImage.Width--------------------------------//
  int previousWidth = 0;
  int rem = 0;

  if( !P )
    return FALSE;

  if( P->mOptions.PlotSize_Width_cm % 2 ) 
    P->mAxes.Width = P->mOptions.PlotSize_Width_cm*CPLOT_PIXELS_PER_CM + 2;
  else
    P->mAxes.Width = P->mOptions.PlotSize_Width_cm*CPLOT_PIXELS_PER_CM;

  P->mAxes.Height = P->mOptions.PlotSize_Height_cm*CPLOT_PIXELS_PER_CM;

  if( P->mOptions.title == NULL )
    P->mTitleAllowance = 50;

  if( P->mOptions.x.label == NULL )
    P->mXLabelAllowance = 15;

  if( P->mOptions.y_label_right != NULL )
    P->mRightYLabelAllowance = 112;

  previousWidth = P->mImage.Width;
  P->mImage.Width  = P->mAxes.Width  + P->mRightYLabelAllowance + P->mYLabelAllowance;

  // The width must be evely divisible by four
  rem = P->mImage.Width%4;
  P->mImage.Width += rem;  

  P->mImage.Height = P->mAxes.Height + P->mXLabelAllowance + P->mTitleAllowance;

  if( P->mImage.Width < 700 &&
    P->mOptions.plotStatistics &&
    P->mOptions.plotLabelOnRight == FALSE )
  {
    P->mImage.Width = 700;
  }

  // define the start and end of the plot window
  P->mAxes.StartX    = P->mYLabelAllowance; // fixed
  P->mAxes.FinishX   = P->mAxes.StartX + P->mAxes.Width;   

  P->mAxes.StartY     = P->mXLabelAllowance;
  P->mAxes.FinishY    = P->mAxes.StartY + P->mAxes.Height;   


  // increase the Figure height or width for
  // labeling only or
  // stats box on right or
  // stats box on bottom
  if( P->mOptions.plotLabelOnRight )
  {
    if( P->mOptions.plotStatistics )
    {
      P->mLabelWidth = 112;
      switch( P->mOptions.numberOfSeries )
      {
      case 1:
      case 2:
      case 3: P->mImage.Width += P->mOptions.numberOfSeries*P->mLabelWidth + 44; break;    
      case 4: 
      case 5: 
      case 6: 
      case 7:
      case 8:
      case 9: 
      case 10:
      case 11:
      case 12: P->mImage.Width += 3*P->mLabelWidth + 44; break;
      default: break;
      }         
    }
    else
    {
      P->mImage.Width += 120;
    }
  }
  else
  {
    P->mImage.Height += P->mOptions.numberOfSeries*20 + 20;
    P->mAxes.StartY  += P->mOptions.numberOfSeries*20 + 20;
    P->mAxes.FinishY += P->mOptions.numberOfSeries*20 + 20;
  }

  if( previousWidth > P->mImage.Width )
    P->mImage.Width = previousWidth;

  // The width must be evely divisible by four
  rem = P->mImage.Width%4;
  P->mImage.Width += rem;  


  if( !CPLOT_BYTE_MTX_calloc( &(P->mPlotData), P->mImage.Height, P->mImage.Width ) )
    return FALSE;

  return TRUE;  
}


BOOL CPLOT_IsNAN( double value )
{
#ifdef WIN32
  if( _isnan( value ) )
    return TRUE;  
  else
    return FALSE;  
#else
  if( isnan( value ) )
    return TRUE;  
  else
    return FALSE;  
#endif
}



BOOL CPLOT_IsPostiveINF( double value )
{
#ifdef WIN32
  if( _finite( value ) )
  {
    return FALSE;
  }
  else
  {
    if( value > 0 )
      return TRUE;
    else
      return FALSE;
  }    
#else
  if( isfinite( value ) )
  {
    return FALSE;
  }
  else
  {
    if( value > 0 )
      return TRUE;
    else
      return FALSE;
  }    
#endif
}


BOOL CPLOT_IsNegativeINF( double value )
{
#ifdef WIN32
  if( _finite( value ) )
  {
    return FALSE;
  }
  else
  {
    if( value < 0 )
      return TRUE;
    else
      return FALSE;
  }    
#else
  if( isfinite( value ) )
  {
    return FALSE;
  }
  else
  {
    if( value < 0 )
      return TRUE;
    else
      return FALSE;
  }    
#endif
}




BOOL CPLOT_DetermineSeriesStatistics( CPLOT_structSeries *series )
{
  int i;
  int n; // the number of items in the series.
  int n_tmp; // the number of items that are not NaN.
  int index_a;
  int index_b;
  double sumx2 = 0;
  double sumx = 0;
  BOOL isIPPSEnabled = FALSE;
  BOOL computeStats = TRUE;
  
  if( !series )
    return FALSE;

  index_a = index_b = 0;
  n = series->n;

  memset( &(series->xStats), 0, sizeof(CPLOT_structStats) );
  memset( &(series->yStats), 0, sizeof(CPLOT_structStats) );
    
  if( n == 0 )
  {
    return TRUE;
  }

  if( n == 1 )
  {
    series->xStats.min   = series->X[0];
    series->xStats.max   = series->X[0];
    series->xStats.mean  = series->X[0];
    series->xStats.stdev = 0.0;
    series->xStats.rms   = series->X[0];
    series->xStats.range = 0.0;

    series->yStats.min   = series->Y[0];
    series->yStats.max   = series->Y[0];
    series->yStats.mean  = series->Y[0];
    series->yStats.stdev = 0.0;
    series->yStats.rms   = series->Y[0];
    series->yStats.range = 0.0;
    return TRUE;
  }

#ifdef INTEL_IPPS

  isIPPSEnabled = TRUE;
  
  if( ippsMinMaxIndx_64f( series->X, n, &(series->xStats.min), &index_a, &(series->xStats.max), &index_b ) != ippStsNoErr )
    return FALSE;
  if( series->xStats.min > series->X[index_a] ) // possible IPPS bug due to NaN or INF
    series->xStats.min = series->X[index_a];
  if( series->xStats.max < series->X[index_b] ) // possible IPPS bug due to NaN or INF
    series->xStats.max = series->X[index_b];

  if( ippsMinMaxIndx_64f( series->Y, n, &(series->yStats.min), &index_a, &(series->yStats.max), &index_b ) != ippStsNoErr )
    return FALSE;
  if( series->yStats.min > series->Y[index_a] ) // possible IPPS bug due to NaN or INF
    series->yStats.min = series->Y[index_a];
  if( series->yStats.max < series->Y[index_b] ) // possible IPPS bug due to NaN or INF
    series->yStats.max = series->Y[index_b];

  series->xStats.range = series->xStats.max - series->xStats.min;
  series->yStats.range = series->yStats.max - series->yStats.min;

  if( ippsSum_64f( series->X, n, &(series->xStats.mean) ) != ippStsNoErr )  
    return FALSE;
  series->xStats.mean /= (double)(n);

  if( ippsSum_64f( series->Y, n, &(series->yStats.mean) ) != ippStsNoErr )  
    return FALSE;
  series->yStats.mean /= (double)(n);

  // Compute RMS
  if( ippsNorm_L2_64f( series->X, n, &(series->xStats.rms) ) != ippStsNoErr )  
    return FALSE;
  series->xStats.rms /= sqrt( (double)(n));
  if( ippsNorm_L2_64f( series->Y, n, &(series->yStats.rms) ) != ippStsNoErr )  
    return FALSE;
  series->yStats.rms /= sqrt( (double)(n));

  computeStats = FALSE;

#endif

  if( isIPPSEnabled )
  {
    // Check IPPS for NaN and INF bad values.
    do
    {
      if( CPLOT_IsNAN( series->xStats.min ) || CPLOT_IsPostiveINF( series->xStats.min ) || CPLOT_IsNegativeINF( series->xStats.min ) )
      {
        computeStats = TRUE;
        break;
      }
      if( CPLOT_IsNAN( series->xStats.max ) || CPLOT_IsPostiveINF( series->xStats.max ) || CPLOT_IsNegativeINF( series->xStats.max ) )
      {
        computeStats = TRUE;
        break;
      }
      if( CPLOT_IsNAN( series->xStats.mean ) || CPLOT_IsPostiveINF( series->xStats.mean ) || CPLOT_IsNegativeINF( series->xStats.mean ) )
      {
        computeStats = TRUE;
        break;
      }
      if( CPLOT_IsNAN( series->xStats.rms ) || CPLOT_IsPostiveINF( series->xStats.rms ) || CPLOT_IsNegativeINF( series->xStats.rms ) )
      {
        computeStats = TRUE;
        break;
      }
    }while(0);
  }

  // These statistics ignore NaN and INF values for min, max, range, mean. 
  // stdev and RMS will ignore NaN but not INF.
  if( computeStats ) 
  {
    series->xStats.min = DBL_MAX;
    series->xStats.max = -DBL_MAX;
    n_tmp = 0;
    for( i = 0; i < n; i++ )
    {
      // ignore NaN and INF.
      if( CPLOT_IsNAN( series->X[i] ) || CPLOT_IsPostiveINF( series->X[i] ) || CPLOT_IsNegativeINF( series->X[i] ) )
        continue;

      if( series->X[i] < series->xStats.min )
      {
        series->xStats.min = series->X[i];
      }
      if( series->X[i] > series->xStats.max )
      {
        series->xStats.max = series->X[i];
      }
      series->xStats.mean += series->X[i];
      n_tmp++;
    }
    series->xStats.range = series->xStats.max - series->xStats.min;
    if( n_tmp )
    {
      series->xStats.mean /= (double)(n_tmp);
    }


    series->yStats.min = DBL_MAX;
    series->yStats.max = -DBL_MAX;
    n_tmp = 0;
    for( i = 0; i < n; i++ )
    {
      // ignore NaN and INF.
      if( CPLOT_IsNAN( series->Y[i] ) || CPLOT_IsPostiveINF( series->Y[i] ) || CPLOT_IsNegativeINF( series->Y[i] ) )
        continue;

      if( series->Y[i] < series->yStats.min )
      {
        series->yStats.min = series->Y[i];
      }
      if( series->Y[i] > series->yStats.max )
      {
        series->yStats.max = series->Y[i];
      }
      series->yStats.mean += series->Y[i];
      n_tmp++;
    }
    series->yStats.range = series->yStats.max - series->yStats.min;
    if( n_tmp )
    {
      series->yStats.mean /= (double)(n_tmp);
    }

    // Compute RMS
    series->xStats.rms = 0;
    n_tmp = 0;
    for( i = 0; i < n; i++ )
    {
      if( !CPLOT_IsNAN( series->X[i] ) )
      {
        series->xStats.rms += series->X[i] * series->X[i];    
        n_tmp++;
      }
    }
    if( n_tmp )
    {
      series->xStats.rms /= (double)(n_tmp);
      series->xStats.rms = sqrt(series->xStats.rms);
    }

    series->yStats.rms = 0;
    n_tmp = 0;
    for( i = 0; i < n; i++ )
    {
      if( !CPLOT_IsNAN( series->Y[i] ) )
      {
        series->yStats.rms += series->Y[i] * series->Y[i];    
        n_tmp++;
      }
    }
    if( n_tmp )
    {
      series->yStats.rms /= (double)(n_tmp);
      series->yStats.rms = sqrt(series->yStats.rms);
    }
  }

  // Always compute stdev 'manually'.
  n_tmp = 0;
  for( i = 0; i < n; i++ )
  {
    if( !CPLOT_IsNAN( series->X[i] ) )
    {
      sumx  += series->X[i];
      sumx2 += series->X[i]*series->X[i];
      n_tmp++;
    }
  }  
  if( CPLOT_IsPostiveINF( sumx2 ) )
  {
    series->xStats.stdev = sumx2;
  }
  else
  {
    series->xStats.stdev = (n_tmp*sumx2 - sumx*sumx) / (n_tmp*(n_tmp-1.0)); // variance
    series->xStats.stdev = sqrt(series->xStats.stdev);  
  }

  n_tmp = 0;
  sumx = 0;
  sumx2 = 0;
  for( i = 0; i < n; i++ )
  {
    if( !CPLOT_IsNAN( series->Y[i] ) )
    {
      sumx  += series->Y[i];
      sumx2 += series->Y[i]*series->Y[i];
      n_tmp++;
    }
  }  
  if( CPLOT_IsPostiveINF( sumx2 ) )
  {
    series->xStats.stdev = sumx2;
  }
  else
  {
    series->yStats.stdev = (n_tmp*sumx2 - sumx*sumx) / (n_tmp*(n_tmp-1.0)); // variance
    series->yStats.stdev = sqrt(series->yStats.stdev);  
  }

  return TRUE;
}


BOOL CPLOT_DetermineScaleFactors( CPLOT *P, CPLOT_structSeries *Series )
{
  double val = 0;
  typedef struct 
  {
    double lowerlimit;
    double upperlimit;
    double tickstart;
    double ticksize;
    double tickend;
  } _structAxis;
  _structAxis x;
  _structAxis y;

  if( !P )
    return FALSE;

  // First deal with the upper and lower limits and the tick values.
  //

  // Special case - all defaults indicated
  if( !P->mOptions.x.lowerlimit.doNotUseDefault &&
    !P->mOptions.x.upperlimit.doNotUseDefault &&
    !P->mOptions.x.tickstart.doNotUseDefault &&
    !P->mOptions.x.tickend.doNotUseDefault )
  {
    val = Series->xStats.min;
    if( val < 0 )
    {
      val = -ceil( -val * 10.0 ) / 10.0;
    }
    else
    {
      val = floor( val * 10.0 ) / 10.0;        
    }
    x.lowerlimit = val;
    
    val = Series->xStats.max;
    if( val < 0 )
    {
      val = -floor( -val * 10.0 ) / 10.0;      
    }
    else
    {
      val = ceil( val * 10.0 ) / 10.0;        
    }
    x.upperlimit = val;

    
    if( x.lowerlimit == x.upperlimit )
    {
      x.lowerlimit -= x.lowerlimit/100.0;
      x.upperlimit += x.upperlimit/100.0;
    }
        
    x.tickstart = x.lowerlimit;
    x.ticksize = (x.upperlimit-x.lowerlimit)/5.0; 
    x.tickend = x.upperlimit;
  }
  else 
  {  
    // deal with mixed or all user specified case

    if( P->mOptions.x.lowerlimit.doNotUseDefault )
      x.lowerlimit = P->mOptions.x.lowerlimit.val;
    else
      x.lowerlimit = Series->xStats.min;

    if( P->mOptions.x.upperlimit.doNotUseDefault )
      x.upperlimit = P->mOptions.x.upperlimit.val;
    else
      x.upperlimit = Series->xStats.max;

    if( P->mOptions.x.tickstart.doNotUseDefault )
      x.tickstart = P->mOptions.x.tickstart.val;
    else
      x.tickstart = x.lowerlimit;

    if( P->mOptions.x.tickend.doNotUseDefault )
      x.tickend = P->mOptions.x.tickend.val;
    else
      x.tickend = x.upperlimit;

    if( P->mOptions.x.ticksize.doNotUseDefault )
      x.ticksize = P->mOptions.x.ticksize.val;
    else
      x.ticksize = (x.tickend - x.tickstart)/5.0;
  }
  if( x.lowerlimit == x.upperlimit )
    return FALSE;
  if( x.tickstart == x.tickend )
    return FALSE;
  if( x.ticksize <= 0.0 )
    return FALSE;



  // Special case - all defaults indicated
  if( !P->mOptions.y.lowerlimit.doNotUseDefault &&
    !P->mOptions.y.upperlimit.doNotUseDefault &&
    !P->mOptions.y.tickstart.doNotUseDefault &&
    !P->mOptions.y.tickend.doNotUseDefault )
  {
    val = Series->yStats.min;
    if( val < 0 )
    {
      val = -ceil( -val * 10.0 ) / 10.0;
    }
    else
    {
      val = floor( val * 10.0 ) / 10.0;        
    }
    y.lowerlimit = val;
    
    val = Series->yStats.max;
    if( val < 0 )
    {
      val = -floor( -val * 10.0 ) / 10.0;      
    }
    else
    {
      val = ceil( val * 10.0 ) / 10.0;        
    }
    y.upperlimit = val;

    
    if( y.lowerlimit == y.upperlimit )
    {
      y.lowerlimit -= y.lowerlimit/100.0;
      y.upperlimit += y.upperlimit/100.0;
    }
        
    y.tickstart = y.lowerlimit;
    y.ticksize = (y.upperlimit-y.lowerlimit)/10.0; 
    y.tickend = y.upperlimit;
  }
  else 
  {  
    // deal with mixed or all user specified case

    if( P->mOptions.y.lowerlimit.doNotUseDefault )
      y.lowerlimit = P->mOptions.y.lowerlimit.val;
    else
      y.lowerlimit = Series->yStats.min;

    if( P->mOptions.y.upperlimit.doNotUseDefault )
      y.upperlimit = P->mOptions.y.upperlimit.val;
    else
      y.upperlimit = Series->yStats.max;

    if( P->mOptions.y.tickstart.doNotUseDefault )
      y.tickstart = P->mOptions.y.tickstart.val;
    else
      y.tickstart = y.lowerlimit;

    if( P->mOptions.y.tickend.doNotUseDefault )
      y.tickend = P->mOptions.y.tickend.val;
    else
      y.tickend = y.upperlimit;

    if( P->mOptions.y.ticksize.doNotUseDefault )
      y.ticksize = P->mOptions.y.ticksize.val;
    else
      y.ticksize = (y.tickend - y.tickstart)/10.0;
  }
  if( y.lowerlimit == y.upperlimit )
    return FALSE;
  if( y.tickstart == y.tickend )
    return FALSE;  
  if( y.ticksize <= 0.0 )
    return FALSE;

  // All the values for lower, upper, and ticks are now set.

  P->mOptions.x.lowerlimit.val = x.lowerlimit;
  P->mOptions.x.upperlimit.val = x.upperlimit;
  P->mOptions.x.tickstart.val = x.tickstart;
  P->mOptions.x.ticksize.val = x.ticksize;
  P->mOptions.x.tickend.val = x.tickend;

  P->mOptions.x.lowerlimit.doNotUseDefault = TRUE;
  P->mOptions.x.upperlimit.doNotUseDefault = TRUE;
  P->mOptions.x.tickstart.doNotUseDefault = TRUE;
  P->mOptions.x.ticksize.doNotUseDefault = TRUE;
  P->mOptions.x.tickend.doNotUseDefault = TRUE;

  P->mOptions.y.lowerlimit.val = y.lowerlimit;
  P->mOptions.y.upperlimit.val = y.upperlimit;
  P->mOptions.y.tickstart.val = y.tickstart;
  P->mOptions.y.ticksize.val = y.ticksize;
  P->mOptions.y.tickend.val = y.tickend;

  P->mOptions.y.lowerlimit.doNotUseDefault = TRUE;
  P->mOptions.y.upperlimit.doNotUseDefault = TRUE;
  P->mOptions.y.tickstart.doNotUseDefault = TRUE;
  P->mOptions.y.ticksize.doNotUseDefault = TRUE;
  P->mOptions.y.tickend.doNotUseDefault = TRUE;


  P->mData.RangeX = x.upperlimit - x.lowerlimit;
  P->mData.RangeY = y.upperlimit - y.lowerlimit;
  
  if( CPLOT_IsPostiveINF( P->mData.RangeX ) )
  {
    return FALSE;
  }
  if( CPLOT_IsPostiveINF( P->mData.RangeY ) )
  {
    return FALSE;
  }

  if( P->mData.RangeX == 0.0 )
    P->mData.RangeX = 0.1;
  if( P->mData.RangeY == 0.0 )
    P->mData.RangeY = 0.1;

  P->mData.OnePercentRangeX = P->mData.RangeX / 100.0;
  P->mData.OnePercentRangeY = P->mData.RangeY / 100.0;
  P->mData.ScaleX  = P->mAxes.Width  / P->mData.RangeX;
  P->mData.ScaleY  = P->mAxes.Height / P->mData.RangeY;

  P->mData.MinX = x.lowerlimit;
  P->mData.MaxX = x.upperlimit;
  P->mData.MinY = y.lowerlimit;
  P->mData.MaxY = y.upperlimit;

  P->mData.xtickstart = x.tickstart;
  P->mData.xtickend   = x.tickend;
  P->mData.ytickstart = y.tickstart;
  P->mData.ytickend   = y.tickend;

  P->mData.xticksize = x.ticksize;
  P->mData.yticksize = y.ticksize;

  return TRUE;
}


BOOL CPLOT_GPSLabel( CPLOT *P, double tow, const int x )
{
  // for gpslabel
  int sec_since_midnight = 0,
    hour    = 0,
    minute  = 0,
    second  = 0,
    scount  = 0;
  char timeString[64];

  if( !P )
    return FALSE;

  if( tow < 0 )
    return FALSE;

  tow += P->mOptions.UTCOffset;

  sec_since_midnight = (int)floor( fmod( tow, 86400.0 ) );
  hour = sec_since_midnight / 3600;
  sec_since_midnight -= hour*3600;

  minute = sec_since_midnight / 60;
  sec_since_midnight -= minute*60;
  second = sec_since_midnight;

  if( hour < 10 )
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    scount += sprintf_s( timeString+scount, 64-scount, "0%d:", hour );
#else
    scount += sprintf( timeString+scount, "0%d:", hour );
#endif
  }
  else 
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    scount += sprintf_s( timeString+scount, 64-scount, "%d:", hour );
#else
    scount += sprintf( timeString+scount, "%d:", hour );
#endif
  }
  if( minute < 10 )
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    scount += sprintf_s( timeString+scount, 64-scount, "0%d:", minute );
#else
    scount += sprintf( timeString+scount, "0%d:", minute );
#endif
  }
  else
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    scount += sprintf_s( timeString+scount, 64-scount, "%d:", minute );
#else
    scount += sprintf( timeString+scount, "%d:", minute );
#endif
  }
  if( second < 10 )
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    scount += sprintf_s( timeString+scount, 64-scount, "0%d", second );
#else
    scount += sprintf( timeString+scount, "0%d", second );
#endif
  }
  else
  {
#ifndef _CRT_SECURE_NO_DEPRECATE
    scount += sprintf_s( timeString+scount, 64-scount, "%d", second );
#else
    scount += sprintf( timeString+scount, "%d", second );
#endif
  }

  if( !CPLOT_DrawString( P, timeString, x, P->mAxes.StartY - 20, TRUE, FALSE, CPLOT_BLACK ) )
    return FALSE;

  return TRUE;
}


BOOL CPLOT_Title( 
  CPLOT *P,
  const char* title 
  )
{  
  int length;
  int hpos;

  if( !P )
    return FALSE;
  if( !title )
    return FALSE;

  length = (int)strlen(title)*CPLOT_SMALLFONT_WIDTH;

  hpos = P->mAxes.StartX/2 + (P->mAxes.Width - length) / 2; 

  if( hpos < 0 ) // title is too long    
    return TRUE;

  if( !CPLOT_DrawString( P, title, hpos, P->mAxes.FinishY + 30, TRUE, FALSE, CPLOT_BLACK ) )
    return FALSE;

  return TRUE;
}

BOOL CPLOT_xLabel( 
  CPLOT *P,
  const char* label 
  )
{
  int length;
  int hpos;

  if( !P )
    return FALSE;
  if( !label )
    return FALSE;

  length = (int)strlen(label)*CPLOT_SMALLFONT_WIDTH;

  hpos = P->mAxes.StartX/2 + (P->mAxes.Width - length) / 2; 

  if( hpos < 0 ) // label is too long
    return TRUE;

  if( !CPLOT_DrawString( P, label, hpos, P->mAxes.StartY - 35, TRUE, FALSE, CPLOT_BLACK ) )
    return FALSE;

  return TRUE;
}


BOOL CPLOT_yLabel( 
  CPLOT *P,
  const char* label, 
  BOOL onLeft 
  )
{
  int length;
  int vpos;

  if( !P )
    return FALSE;
  if( !label )
    return FALSE;

  length = (int)strlen(label)*CPLOT_SMALLFONT_WIDTH;   

  vpos = P->mAxes.StartY + (P->mAxes.Height - length) / 2; 

  if( vpos < 0 ) // label is too long
    return TRUE;

  if( onLeft )
  {
    if( !CPLOT_DrawString( P, label, 8, vpos, TRUE, TRUE, CPLOT_BLACK ) )
      return FALSE;
  }
  else
  {
    if( !CPLOT_DrawString( P, label, P->mAxes.FinishX+80, vpos, TRUE, TRUE, P->mOptions.RightYLabelColor ) )
      return FALSE;
  }
  return TRUE;
}



BOOL CPLOT_DrawPoint( 
  CPLOT *P,
  const int x, 
  const int y,
  const CPLOT_enumColor color 
  )
{
  int i;
  int j;

  if( !P )
    return FALSE;

  if( y < 3 )
    return TRUE;

  if( x + 3 >= P->mImage.Width )
    return TRUE;

  for( i = 0; i < CPLOT_POINT_SIZE; i++ )
  {
    for( j = 0; j < CPLOT_POINT_SIZE; j++ )
    {
      // Only draw the point, the rest is transparent.
      if( CPLOT_Point[i][j] )
      {
        if( y-i+2 >= (int)P->mPlotData.nrows )
          return FALSE;
        if( x+j-2 >= (int)P->mPlotData.ncols )
          return FALSE;        
        P->mPlotData.data[y-i+2][x+j-2] = color;
      }
    }
  }
  return TRUE;
}



BOOL CPLOT_DrawLargePoint( 
  CPLOT *P,
  const int x, 
  const int y,
  const CPLOT_enumColor color 
  )
{
  int i;
  int j;

  if( !P )
    return FALSE;
  
  if( y < 3 )
    return TRUE;
  
  if( x + 3 >= P->mImage.Width )
    return TRUE;

  for( i = 0; i < CPLOT_LARGEPOINT_SIZE; i++ )
  {
    for( j = 0; j < CPLOT_LARGEPOINT_SIZE; j++ )
    {
      // Only draw the point, the rest is transparent.
      if( CPLOT_LargePoint[i][j] )
      {
        if( y-i+2 >= (int)P->mPlotData.nrows )
          return FALSE;
        if( x+j-2 >= (int)P->mPlotData.ncols )
          return FALSE;
        P->mPlotData.data[y-i+2][x+j-2] = color;
      }
    }
  }
  return TRUE;
}





BOOL CPLOT_DrawLegendLabel( 
  CPLOT *P,
  const char* label,
  const char* units,
  const CPLOT_enumColor color 
  )
{
  int ypos = 0;
  int xpos = 0;
  int xoffset = P->mRightYLabelAllowance + 47;
  char buffer[128];

  if( !P )
    return FALSE;
  if( !label )
    return FALSE;

  if( strlen(label) < 1 )
    return FALSE;
  
  if( P->mOptions.plotLabelOnRight )
  {
    if( P->mOptions.plotStatistics )
    {
      switch( P->mSeriesIndex )
      {
      case 0:
      case 1:
      case 2: 
        xpos = P->mAxes.FinishX + xoffset + P->mSeriesIndex*P->mLabelWidth;
        ypos = P->mAxes.FinishY - 8; 
        break;
      case 3:
      case 4:
      case 5: 
        xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex-3)*P->mLabelWidth;
        ypos = P->mAxes.FinishY - 8 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8);
        break;
      case 6:
      case 7:
      case 8: 
        xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex-6)*P->mLabelWidth;
        ypos = P->mAxes.FinishY - 8 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8);
        break;
      case 9:
      case 10:
      case 11: 
        xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex-9)*P->mLabelWidth;
        ypos = P->mAxes.FinishY - 8 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8);
        break;          
      default: 
        return TRUE; // no more than 12 series possible               
      }         
      if( !CPLOT_DrawLargePoint( P, xpos - 5, ypos-6, color ) )
        return FALSE;
      //DrawPoint( xpos - 6, ypos-6, color );
      //DrawPoint( xpos - 4, ypos-6, color );
      if( !CPLOT_DrawString( P, label, xpos, ypos, TRUE, FALSE, color ) )
        return FALSE;
      if( !CPLOT_DrawString( P, units, xpos, ypos - P->mStatsValueHeight, TRUE, FALSE, color ) )
        return FALSE;
    }
    else
    {
      xpos = P->mAxes.FinishX + P->mRightYLabelAllowance;         
      ypos = P->mAxes.FinishY - 16*(P->mSeriesIndex) - P->mStatsValueHeight*8;
      if( !CPLOT_DrawLargePoint( P, xpos - 8, ypos, color ) )
        return FALSE;
      //DrawPoint( xpos - 6, ypos, color );
      //DrawPoint( xpos - 4, ypos, color );
      if( units && label )
      {
#ifndef _CRT_SECURE_NO_DEPRECATE
        sprintf_s( buffer, 128, "%s %s", label, units );
#else
        sprintf( buffer, "%s %s", label, units );
#endif
      }
      else if ( label )
      {
#ifndef _CRT_SECURE_NO_DEPRECATE
        sprintf_s( buffer, 128, "%s", label );
#else
        sprintf( buffer, "%s", label );
#endif
      }
      else
        buffer[0] = '\0';
      if( !CPLOT_DrawString( P, buffer, xpos, ypos + 3, TRUE, FALSE, CPLOT_BLACK ) )
        return FALSE;
    }
  }
  else
  {
    xpos = 16;      
    ypos = P->mAxes.StartY - P->mXLabelAllowance - 8 - P->mStatsValueHeight*(P->mSeriesIndex+1);      
    if( !CPLOT_DrawLargePoint( P, xpos - 8, ypos - 5, color ) )
      return FALSE;
    //DrawPoint( xpos - 6, ypos - 5, color );
    //DrawPoint( xpos - 4, ypos - 5, color );
    if( !CPLOT_DrawString( P, label, xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    if( !CPLOT_DrawString( P, units, 600, ypos, TRUE, FALSE, color ) )
      return FALSE;
  }
  return TRUE;
}





BOOL CPLOT_DrawAxes( 
  CPLOT *P,
  CPLOT_structSeries *Series,
  const CPLOT_enumColor color 
  )
{
  double x = 0.0;
  double y = 0.0;

  double xTickRange = 0;
  double yTickRange = 0;
  
  int xtick;
  int ytick;


  // resize the figure if needed
  if( !CPLOT_ResizePlot(P) )
    return FALSE;

  // GDM_TODO - What is the point of this part?
  if( !P->mOptions.redrawAxes )
  {
    CPLOT_BYTE_MTX_Fill( &(P->mPlotData), P->mOptions.figureBackgroundColor );
  }
    

  // first draw the box   
  if( !CPLOT_DrawLine( P, P->mAxes.StartX,  P->mAxes.StartY,  P->mAxes.FinishX, P->mAxes.StartY, color) )  //bottom
    return FALSE;
  if( !CPLOT_DrawLine( P, P->mAxes.StartX,  P->mAxes.StartY,  P->mAxes.StartX,  P->mAxes.FinishY, color) ) //left side
    return FALSE;
  if( !CPLOT_DrawLine( P, P->mAxes.StartX,  P->mAxes.FinishY, P->mAxes.FinishX, P->mAxes.FinishY, color) ) //top
    return FALSE;
  if( !CPLOT_DrawLine( P, P->mAxes.FinishX, P->mAxes.StartY,  P->mAxes.FinishX, P->mAxes.FinishY, color) ) //right side
    return FALSE;

  // determine the mapping scale factors
  if( !CPLOT_DetermineScaleFactors( P, Series ) )
    return FALSE;

  xTickRange = P->mData.xtickend - P->mData.xtickstart;
  yTickRange = P->mData.ytickend - P->mData.ytickstart;

  // plot the xticks   
  for( x = P->mData.xtickstart; x <= P->mData.xtickend + P->mData.OnePercentRangeX; x += P->mData.xticksize )
  {
    if( Series->xStats.range > 1e-6 )
    {
      if( fabs(x) < 1e-6 )
        x = 0;
    }
    xtick = (int)( (x   - P->mData.MinX)*P->mData.ScaleX ) + P->mAxes.StartX;

    if( !CPLOT_DrawLine( P, xtick, P->mAxes.StartY,                               xtick, P->mAxes.StartY  + P->mAxes.TickDashInPixels, CPLOT_BLACK ) ) // bottom ticks
      return FALSE;
    if( !CPLOT_DrawLine( P, xtick, P->mAxes.FinishY - P->mAxes.TickDashInPixels , xtick, P->mAxes.FinishY,                          CPLOT_BLACK ) ) // top ticks      
      return FALSE;

    if( P->mOptions.x.label )
    {
      if( !CPLOT_DrawValue( P, TRUE,  x, xtick - 3, P->mAxes.StartY - 5, color ) )
        return FALSE;

      if( P->mOptions.useGPSLabel )
        CPLOT_GPSLabel( P, x, xtick - 3  );
    }
    if( P->mOptions.x.isGridOn )
    {
      if( !CPLOT_DrawDashedLine( P, xtick, P->mAxes.StartY,  xtick, P->mAxes.FinishY, 2, color ) )
        return FALSE;
    }
  }

  // plot the yticks
  for( y = P->mData.ytickstart; y <= P->mData.ytickend + P->mData.OnePercentRangeY; y += P->mData.yticksize )
  {
    if( Series->yStats.range > 1e-6 )
    {
      if( fabs(y) < 1e-6 )
        y = 0;
    }    
    ytick = (int)( (y   - P->mData.MinY)*P->mData.ScaleY ) + P->mAxes.StartY;

    if( !CPLOT_DrawLine( P, P->mAxes.StartX,                              ytick, P->mAxes.StartX  + P->mAxes.TickDashInPixels, ytick, color ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, P->mAxes.FinishX - P->mAxes.TickDashInPixels, ytick, P->mAxes.FinishX,                             ytick, color ) )
      return FALSE;

    if( P->mOptions.y.label )         
    {
      if( !CPLOT_DrawValue( P, FALSE,  y, P->mAxes.StartX - CPLOT_SMALLFONT_WIDTH*15, ytick + 7, color ) )
        return FALSE;
    }

    if( P->mOptions.y.isGridOn )
    {
      if( !CPLOT_DrawDashedLine( P, P->mAxes.StartX, ytick, P->mAxes.FinishX, ytick, 2, color ) )
        return FALSE;
    }

    if( P->mOptions.y_label_right != NULL )
    {
      double value = y / P->mOptions.y_label_right_scale_factor - P->mOptions.y_label_right_bias;
      if( !CPLOT_DrawValue( P, TRUE,  value, P->mAxes.FinishX + 3, ytick + 7, P->mOptions.RightYLabelColor ) )
        return FALSE;
    }
  }


  // draw title, labels and such
  if( P->mOptions.title )
    if( !CPLOT_Title( P, P->mOptions.title ) )
      return FALSE;
  if( P->mOptions.x.label )
    if( !CPLOT_xLabel( P, P->mOptions.x.label ) )
      return FALSE;
  if( P->mOptions.y.label )
    if( !CPLOT_yLabel( P, P->mOptions.y.label, TRUE ) )
      return FALSE;
  if( P->mOptions.y_label_right )
    if( !CPLOT_yLabel( P, P->mOptions.y_label_right, FALSE ) )
      return FALSE;
  
  return TRUE;
}



BOOL CPLOT_DrawStatsValue(
  CPLOT *P,
  double value, 
  const int left, 
  const int top,
  const CPLOT_enumColor color,
  const int precision 
  )
{
  char formatBuffer[48];
  char ValueBuffer[48];
  ValueBuffer[0] = '\0';

  if( !P )
    return FALSE;

#ifndef _CRT_SECURE_NO_DEPRECATE
  sprintf_s( formatBuffer, 48, "%%%d.%dg", P->mLabelWidth/CPLOT_SMALLFONT_WIDTH, precision );
  sprintf_s( ValueBuffer, 48, formatBuffer, value );
#else
  sprintf( formatBuffer, "%%%d.%dg", P->mLabelWidth/CPLOT_SMALLFONT_WIDTH, precision );
  sprintf( ValueBuffer, formatBuffer, value );
#endif

  /*
  if( fabs(value) < 1e-12 )
    value = 0.0;

  if( fabs(value) > 1.0e+8 || (fabs(value) < 1.0e-8 && value != 0.0) )
  {      
    sprintf( formatBuffer, "%%-%d.%de", P->mStatsValueHeight, decimalPrecision );
    sprintf( ValueBuffer, formatBuffer, value );
  }
  else
  {      
    sprintf( formatBuffer, "%%-%d.%df", P->mStatsValueHeight, decimalPrecision );
    sprintf( ValueBuffer, formatBuffer, value );
  } 
  */

  if( (left + P->mLabelWidth) >= P->mImage.Width )
    return TRUE;
  if( top >= P->mImage.Height )
    return TRUE;

  if( !CPLOT_DrawString( P, ValueBuffer, left, top, TRUE, FALSE, color ) )
    return FALSE;

  return TRUE;
}

BOOL CPLOT_DrawStats( 
  CPLOT *P,
  CPLOT_structSeries* Series 
  )
{
  int ypos = 0,
    xpos = 0,
    boxwidth  = 45,
    boxheight = 0,
    yoffset = 0,
    xoffset = 0,
    i = 0;

  int high;
  int low;


  if( !P )
    return FALSE;
  if( !Series )
    return FALSE;

  boxheight = P->mStatsValueHeight*7+1;

  if( P->mOptions.plotLabelOnRight )
  {
    switch( P->mSeriesIndex )
    {
    case 0:
    case 1:
    case 2:  ypos = P->mAxes.FinishY - 6; break;
    default: ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8); break;
      /*
      case 3:
      case 4:
      case 5: ypos = mAxes.FinishY - 6 - (mSeriesIndex/3)*(mStatsValueHeight*8); break;
      case 6:
      case 7:
      case 8: ypos = mAxes.FinishY - 6 - (mSeriesIndex/3)*(mStatsValueHeight*8); break;
      case 9:
      case 10:
      case 11: ypos = mAxes.FinishY - 6 - (mSeriesIndex/3)*(mStatsValueHeight*8); break;
      default: return; // no more than 9 series possible
      */
    }

    // plot the box around the labels (units, min, max, mean, RMS, Stdev)
    xpos = P->mAxes.FinishX + P->mRightYLabelAllowance - 10;
    if( !CPLOT_DrawLine( P, xpos - 2,        ypos - boxheight, xpos -  2,       ypos,              CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, xpos + boxwidth, ypos - boxheight, xpos + boxwidth, ypos,              CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, xpos - 2,        ypos,             xpos + boxwidth, ypos,              CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, xpos - 2,        ypos - boxheight, xpos + boxwidth, ypos - boxheight,  CPLOT_LIGHTGREY ) )
      return FALSE;

    // plot the horizontal lines for the labels on the left
    ypos -= 5;
    ypos -= P->mStatsValueHeight;
    for( i = 0; i < 6; i++ )
    {
      if( !CPLOT_DrawLine( 
        P, 
        xpos - 2,      
        ypos + 5 - P->mStatsValueHeight*i,
        xpos + boxwidth,
        ypos + 5 - P->mStatsValueHeight*i,
        CPLOT_LIGHTGREY ) )
      {
        return FALSE;
      }
    }
    ypos += 2;
    //if( !CPLOT_DrawString( P, "Units", xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
    //  return FALSE;
    ypos -= P->mStatsValueHeight;
    if( !CPLOT_DrawString( P, "Min",   xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    ypos -= P->mStatsValueHeight;
    if( !CPLOT_DrawString( P, "Max",   xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    ypos -= P->mStatsValueHeight;
    if( !CPLOT_DrawString( P, "Mean",  xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    ypos -= P->mStatsValueHeight;
    if( !CPLOT_DrawString( P, "RMS",   xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    ypos -= P->mStatsValueHeight;
    if( !CPLOT_DrawString( P, "\\sigma", xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;


    xoffset = P->mRightYLabelAllowance + 37;
    switch( P->mSeriesIndex )
    {
    case 0:
    case 1:
    case 2:
      xpos = P->mAxes.FinishX + xoffset + P->mSeriesIndex*P->mLabelWidth;
      ypos = P->mAxes.FinishY - 6; 
      break;
    case 3:
    case 4:
    case 5:
      xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex-3)*P->mLabelWidth;
      ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8);
      break;
    case 6:
    case 7:
    case 8:
      xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex-6)*P->mLabelWidth;
      ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8);
      break;
    case 9:
    case 10:
    case 11:
      xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex-9)*P->mLabelWidth;
      ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex/3)*(P->mStatsValueHeight*8);
      break;
    default: 
      return FALSE; // no more than 12 series possible            
    }         

    if( !CPLOT_DrawLine( P, xpos + P->mLabelWidth, ypos - boxheight, xpos + P->mLabelWidth, ypos,             CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, xpos - 2,              ypos,             xpos + P->mLabelWidth, ypos,             CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, xpos - 2,              ypos - boxheight, xpos + P->mLabelWidth, ypos - boxheight, CPLOT_LIGHTGREY ) )
      return FALSE;  

    ypos -= P->mStatsValueHeight*2 + 5;
    for( i = 0; i < 5; i++ )
    {
      if( !CPLOT_DrawLine( 
        P, 
        xpos - 2,       
        ypos + 5 - P->mStatsValueHeight*i, 
        xpos + P->mLabelWidth, 
        ypos + 5 - P->mStatsValueHeight*i,
        CPLOT_LIGHTGREY ) )
      {
        return FALSE;
      }
    }

    xpos += 3;
    ypos += 2;
    if( !CPLOT_DrawStatsValue( P, Series->yStats.min, xpos, ypos, Series->color, Series->precision ) )
      return FALSE;    
    ypos -= P->mStatsValueHeight;         
    if( !CPLOT_DrawStatsValue( P, Series->yStats.max, xpos, ypos, Series->color, Series->precision ) )
      return FALSE;
    ypos -= P->mStatsValueHeight;         
    if( !CPLOT_DrawStatsValue( P, Series->yStats.mean, xpos, ypos, Series->color, Series->precision ) )
      return FALSE;    
    ypos -= P->mStatsValueHeight;         
    if( !CPLOT_DrawStatsValue( P, Series->yStats.rms, xpos, ypos, Series->color, Series->precision ) )
      return FALSE;    
    ypos -= P->mStatsValueHeight;  
    if( !CPLOT_DrawStatsValue( P, Series->yStats.stdev, xpos, ypos, Series->color, Series->precision ) )
      return FALSE;        
  }
  else
  {
    yoffset = P->mXLabelAllowance + 6;
    high = P->mAxes.StartY - yoffset;
    low  = P->mAxes.StartY - yoffset - P->mStatsValueHeight;

    if( !CPLOT_DrawString( P, "Min",    200, high-2, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    if( !CPLOT_DrawLine( P,   6, high, 680, high, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 197, low,  197, high, CPLOT_LIGHTGREY ) )
      return FALSE;

    if( !CPLOT_DrawString( P, "Max",    280, high-2, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 277, low, 277, high, CPLOT_LIGHTGREY ) )
      return FALSE;

    if( !CPLOT_DrawString( P, "Mean",   360, high-2, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 357, low, 357, high, CPLOT_LIGHTGREY ) )
      return FALSE;

    if( !CPLOT_DrawString( P, "RMS",    440, high-2, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 437, low, 437, high, CPLOT_LIGHTGREY ) )
      return FALSE;

    if( !CPLOT_DrawString( P, "\\sigma",  520, high-2, TRUE, FALSE, CPLOT_BLACK ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 517, low, 517, high, CPLOT_LIGHTGREY ) )
      return FALSE;

    //if( !CPLOT_DrawString( P, "Units",  600, high-2, TRUE, FALSE, CPLOT_BLACK ) )
    //  return FALSE;
    if( !CPLOT_DrawLine( P, 597, low, 597, high, CPLOT_LIGHTGREY ) )
      return FALSE;

    if( !CPLOT_DrawLine( P, 6, P->mAxes.StartY-yoffset-P->mStatsValueHeight, 680, P->mAxes.StartY-yoffset-P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 6, P->mAxes.StartY-yoffset-P->mStatsValueHeight, 6, P->mAxes.StartY-yoffset, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 680, P->mAxes.StartY-yoffset-P->mStatsValueHeight, 680, P->mAxes.StartY-yoffset, CPLOT_LIGHTGREY ) )
      return FALSE;

    ypos = P->mAxes.StartY - yoffset - P->mStatsValueHeight*(P->mSeriesIndex+2);

    if( !CPLOT_DrawLine( P, 6,   ypos, 680, ypos, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 6,   ypos, 6,   ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 197, ypos, 197, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 277, ypos, 277, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 357, ypos, 357, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 437, ypos, 437, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 517, ypos, 517, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 597, ypos, 597, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;
    if( !CPLOT_DrawLine( P, 680, ypos, 680, ypos+P->mStatsValueHeight, CPLOT_LIGHTGREY ) )
      return FALSE;

    ypos = P->mAxes.StartY - yoffset - 2 - P->mStatsValueHeight*(P->mSeriesIndex+1);

    if( !CPLOT_DrawStatsValue( P, Series->yStats.min, 200, ypos, Series->color, Series->precision ) ) 
      return FALSE;
    if( !CPLOT_DrawStatsValue( P, Series->yStats.max, 280, ypos, Series->color, Series->precision ) ) 
      return FALSE;
    if( !CPLOT_DrawStatsValue( P, Series->yStats.mean,   360, ypos, Series->color, Series->precision ) ) 
      return FALSE;
    if( !CPLOT_DrawStatsValue( P, Series->yStats.rms,    440, ypos, Series->color, Series->precision ) ) 
      return FALSE;
    if( !CPLOT_DrawStatsValue( P, Series->yStats.stdev,  520, ypos, Series->color, Series->precision ) ) 
      return FALSE;

  }
  return TRUE;
}




BOOL CPLOT_FWriteRGB( FILE* out, CPLOT_structRGB val )
{
  if( !out )
    return FALSE;
  fwrite( &val.Blue, sizeof(byte), 1, out ); 
  fwrite( &val.Green, sizeof(byte), 1, out ); 
  fwrite( &val.Red, sizeof(byte), 1, out ); 
  fwrite( &val.Reserved, sizeof(byte), 1, out );
  return TRUE;
}


/** \brief  The BITMAP file header struct.

\code
start    size    name       stdvalue    purpose
1        2       Type       19778       must always be set to 'BM' to declare that this is a .bmp-file.
3        4       Size       ??          specifies the size of the file in bytes.
7        2       Reserved1  0           must always be set to zero.
9        2       Reserved2  0           must always be set to zero.
11       4       OffBits    1078        specifies the offset from the beginning of the file to the bitmap data.
\endcode
*/
typedef struct 
{
  unsigned short  Type;                 // must be BM //0x4D42
  unsigned long   Size;                 // size in bytes of the file
  unsigned short  Reserved1;            // 0
  unsigned short  Reserved2;            // 0
  unsigned long   OffsetToBitmapBits;   // offset in bytes from BitmapFileHeader to bitmap bits
} CPLOT_structBitmapFileHeader;


/** \brief  The BITMAP file info struct.

\code
start    size    name            stdvalue  purpose
15       4       Size            40        specifies the size of the BITMAPINFOHEADER structure, in bytes.
19       4       Width           100       specifies the width of the image, in pixels.
23       4       Height          100       specifies the height of the image, in pixels.
27       2       Planes          1         specifies the number of planes of the target device, must be set to zero.
29       2       BitCount        8         specifies the number of bits per pixel.
31       4       Compression     0         Specifies the type of compression, usually set to zero (no compression).
35       4       SizeImage       0         specifies the size of the image data, in bytes. If there is no compression, it is valid to set this member to zero.
39       4       XPelsPerMeter   0         specifies the the horizontal pixels per meter on the designated targer device, usually set to zero.
43       4       YPelsPerMeter   0         specifies the the vertical pixels per meter on the designated targer device, usually set to zero.
47       4       ClrUsed         0         specifies the number of colors used in the bitmap, if set to zero the number of colors is calculated using the biBitCount member.
51       4       ClrImportant    0         specifies the number of color that are 'important' for the bitmap, if set to zero, all colors are important.
\endcode
*/
typedef struct 
{
  unsigned long   Size; // size of the stBitmapInfoHeader (does not include the color table)
  long            Width;
  long            Height;
  unsigned short  Planes;
  unsigned short  BitCount;
  unsigned long   Compression;
  unsigned long   SizeImage;
  long            XPelsPerMeter;
  long            YPelsPerMeter;
  unsigned long   ClrUsed;
  unsigned long   ClrImportant;      
} CPLOT_structBitmapInfoHeader;


BOOL CPLOT_SaveToFile( 
  CPLOT *P,
  const char *FileName 
  )
{
  int i = 0,
    j = 0,
    z = 0,
    count = 0,    
    sizeOfColorTable = 0;
  int max_z;

  unsigned compressedSize = 0;

  BOOL first = TRUE;

  byte theByte = 0;
  byte last    = 0;

  CPLOT_structByteMatrix CompressedVector;

  FILE* BmpFile = NULL;

  CPLOT_structBitmapFileHeader BitmapFileHeader; 
  CPLOT_structBitmapInfoHeader BitmapInfoHeader;
  
  CPLOT_BYTE_MTX_Init( &CompressedVector );

  // the image width must be divisible by four
  if( P->mImage.Width%4 != 0 )
    return FALSE;

  memset( &BitmapFileHeader, 0, sizeof(CPLOT_structBitmapFileHeader) ); // don't use preprocesso constants here
  memset( &BitmapInfoHeader, 0, sizeof(CPLOT_structBitmapInfoHeader) ); // don't use preprocesso constants here

  BitmapFileHeader.Type = 0x4D42; //BM

  // assuming the default color table
  BitmapFileHeader.Size = P->mImage.Width*P->mImage.Height + 
    CPLOT_SIZEOF_BITMAPFILEHEADER + 
    CPLOT_SIZEOF_BITMAPINFOHEADER +
    sizeof(CPLOT_structColorTable); // 22*4, works for 1,2,4,8 byte packing
  
  BitmapFileHeader.Reserved1 = 0;
  BitmapFileHeader.Reserved2 = 0;
  BitmapFileHeader.OffsetToBitmapBits = 0; // set later

  BitmapInfoHeader.Size           = CPLOT_SIZEOF_BITMAPINFOHEADER;
  BitmapInfoHeader.Width          = P->mImage.Width;  // pixels
  BitmapInfoHeader.Height         = P->mImage.Height; // pixels
  BitmapInfoHeader.Planes         = 1;
  BitmapInfoHeader.BitCount       = 8;
  BitmapInfoHeader.Compression    = 0; // set later
  BitmapInfoHeader.SizeImage      = P->mImage.Width*P->mImage.Height;
  BitmapInfoHeader.XPelsPerMeter  = 0;
  BitmapInfoHeader.YPelsPerMeter  = 0;
  BitmapInfoHeader.ClrUsed        = 22;
  BitmapInfoHeader.ClrImportant   = 22;


  // compress bitmap using RLE encoding
  // possible to be larger than original, so we'll overallocate by 2  
  max_z = BitmapInfoHeader.SizeImage*2;
  if( max_z > 41943040 ) // about 40 MB 
    return FALSE;
  CPLOT_BYTE_MTX_calloc( &CompressedVector, 1, max_z );

  // place 2d byte matrix into a vector
  for( i = 0; i < (int)P->mPlotData.nrows; i++ )
  {      
    count = 0;
    first = TRUE;
    for( j = 0; j < (int)P->mPlotData.ncols; j++ )
    {
      theByte = P->mPlotData.data[i][j];

      if( first )
      {
        last = theByte;
        count = 1;
        first = FALSE;
        continue;
      }

      if( count == 255 )
      {
        CompressedVector.data[0][z] = count;
        z++;
        if( z >= max_z )
        {
          CPLOT_BYTE_MTX_Free( &CompressedVector );
          return FALSE;
        }
        CompressedVector.data[0][z] = last;
        z++;
        if( z >= max_z )
        {
          CPLOT_BYTE_MTX_Free( &CompressedVector );
          return FALSE;
        }
        first = TRUE;
        count = 0;
        j--;
        continue;
      }

      if( theByte == last )
      {
        count++;
      }
      else
      {
        CompressedVector.data[0][z] = count;
        z++;
        if( z >= max_z )
        {
          CPLOT_BYTE_MTX_Free( &CompressedVector );
          return FALSE;
        }
        CompressedVector.data[0][z] = last;
        z++;
        if( z >= max_z )
        {
          CPLOT_BYTE_MTX_Free( &CompressedVector );
          return FALSE;
        }
        count = 1;
        last = theByte;
      }
    }
    if( count != 0 )
    {
      CompressedVector.data[0][z] = count;
      z++;
      if( z >= max_z )
      {
        CPLOT_BYTE_MTX_Free( &CompressedVector );
        return FALSE;
      }
      CompressedVector.data[0][z] = last;
      z++;
      if( z >= max_z )
      {
        CPLOT_BYTE_MTX_Free( &CompressedVector );
        return FALSE;
      }
    }
    if( i != (int)(P->mPlotData.nrows - 1) )
    {
      CompressedVector.data[0][z] = 0;
      z++;
      if( z >= max_z )
      {
        CPLOT_BYTE_MTX_Free( &CompressedVector );
        return FALSE;
      }
      CompressedVector.data[0][z] = 0;
      z++;
      if( z >= max_z )
      {
        CPLOT_BYTE_MTX_Free( &CompressedVector );
        return FALSE;
      }
    }      
  }

  // indicate end of bitmap
  CompressedVector.data[0][z] = 0;
  z++;
  if( z >= max_z )
  {
    CPLOT_BYTE_MTX_Free( &CompressedVector );
    return FALSE;
  }
  CompressedVector.data[0][z] = 1;
  z++;
  if( z >= max_z )
  {
    CPLOT_BYTE_MTX_Free( &CompressedVector );
    return FALSE;
  }
  compressedSize = z;

  sizeOfColorTable = BitmapInfoHeader.ClrUsed * 4;   
  BitmapFileHeader.OffsetToBitmapBits = CPLOT_SIZEOF_BITMAPFILEHEADER + CPLOT_SIZEOF_BITMAPINFOHEADER + sizeOfColorTable; // 14 + 40 + 88

  // check that compressed is better
  if( compressedSize < BitmapInfoHeader.SizeImage )
  {
    BitmapInfoHeader.Compression = 1;
    BitmapInfoHeader.SizeImage = compressedSize;
    BitmapFileHeader.Size = compressedSize + BitmapFileHeader.OffsetToBitmapBits;
  }

#ifndef _CRT_SECURE_NO_DEPRECATE
  if( fopen_s( &BmpFile, FileName, "wb" ) != 0 )
  {
    CPLOT_BYTE_MTX_Free( &CompressedVector );
    return FALSE;
  }
#else
  BmpFile = fopen(FileName,"wb");
  if( !BmpFile )
  {
    CPLOT_BYTE_MTX_Free( &CompressedVector );
    return FALSE;
  }
#endif

  // write the header, write basic element at a time to avoid struct member packing issues.
  fwrite( &BitmapFileHeader.Type, sizeof(BitmapFileHeader.Type), 1, BmpFile );
  fwrite( &BitmapFileHeader.Size, sizeof(BitmapFileHeader.Size), 1, BmpFile );
  fwrite( &BitmapFileHeader.Reserved1, sizeof(BitmapFileHeader.Reserved1), 1, BmpFile );
  fwrite( &BitmapFileHeader.Reserved2, sizeof(BitmapFileHeader.Reserved2), 1, BmpFile );
  fwrite( &BitmapFileHeader.OffsetToBitmapBits, sizeof(BitmapFileHeader.OffsetToBitmapBits), 1, BmpFile );

  fwrite( &BitmapInfoHeader.Size, sizeof(BitmapInfoHeader.Size), 1, BmpFile );
  fwrite( &BitmapInfoHeader.Width, sizeof(BitmapInfoHeader.Width), 1, BmpFile );
  fwrite( &BitmapInfoHeader.Height, sizeof(BitmapInfoHeader.Height), 1, BmpFile );
  fwrite( &BitmapInfoHeader.Planes, sizeof(BitmapInfoHeader.Planes), 1, BmpFile );
  fwrite( &BitmapInfoHeader.BitCount, sizeof(BitmapInfoHeader.BitCount), 1, BmpFile );
  fwrite( &BitmapInfoHeader.Compression, sizeof(BitmapInfoHeader.Compression), 1, BmpFile );
  fwrite( &BitmapInfoHeader.SizeImage, sizeof(BitmapInfoHeader.SizeImage), 1, BmpFile );
  fwrite( &BitmapInfoHeader.XPelsPerMeter, sizeof(BitmapInfoHeader.XPelsPerMeter), 1, BmpFile );
  fwrite( &BitmapInfoHeader.YPelsPerMeter, sizeof(BitmapInfoHeader.YPelsPerMeter), 1, BmpFile );
  fwrite( &BitmapInfoHeader.ClrUsed, sizeof(BitmapInfoHeader.ClrUsed), 1, BmpFile );
  fwrite( &BitmapInfoHeader.ClrImportant, sizeof(BitmapInfoHeader.ClrImportant), 1, BmpFile );


  if( P->mUseDefaultColorTable )
  {     
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.White );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Black );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Blue );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Green );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Purple );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Magenta );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.DarkBlue );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.IndianRed );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.BabyBlue );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.PaislyBlue );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.LightPurple );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.DarkPurple );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.GreyPurple );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Brown );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Red );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Pink );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Yellow );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Orange );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Cyan );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.LimeGreen );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Grey );
    CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.LightGrey );             
  }
  else
  {
    if( P->mColorTable )
    {
      for( i = 0; i < sizeOfColorTable; i++ )
        fwrite( &(P->mColorTable[i]), sizeof(unsigned char), 1, BmpFile );       
    }
    else
    {
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.White );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Black );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Blue );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Green );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Purple );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Magenta );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.DarkBlue );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.IndianRed );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.BabyBlue );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.PaislyBlue );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.LightPurple );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.DarkPurple );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.GreyPurple );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Brown );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Red );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Pink );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Yellow );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Orange );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Cyan );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.LimeGreen );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.Grey );
      CPLOT_FWriteRGB( BmpFile, P->mDefaultColorTable.LightGrey );             
    }       
  }    


  if( BitmapInfoHeader.Compression == 1 )
  {
    if( fwrite( CompressedVector.data[0], sizeof(byte), compressedSize, BmpFile ) != compressedSize )
    {
      CPLOT_BYTE_MTX_Free( &CompressedVector );
      return FALSE;
    }
    // done
  }
  else
  {
    for( i = 0; i < (int)P->mPlotData.nrows; i++ )
    {
      // write the mPlotData
      if( fwrite( P->mPlotData.data[i], sizeof(byte), P->mPlotData.ncols, BmpFile ) != P->mPlotData.ncols )
      {
        CPLOT_BYTE_MTX_Free( &CompressedVector );
        return FALSE;
      }
    }
  }

  fclose(BmpFile);

  CPLOT_BYTE_MTX_Free( &CompressedVector );
  return TRUE;
}






BOOL CPLOT_SetPlotOptions( 
  CPLOT *P, 
  CPLOT_structPlotOptions *opt
  )
{
  if( !P )
    return FALSE;
  if( !opt )
    return FALSE;

  memcpy( &(P->mOptions), opt, sizeof(CPLOT_structPlotOptions) );
  return TRUE;
}



BOOL CPLOT_Plot( 
  CPLOT *P, 
  CPLOT_structSeries *Series 
  )
{
  int i  = 0;
  int x1 = 0;
  int x2 = 0;
  int y1 = 0;
  int y2 = 0;
  int n = 0;

  double xval_i;
  double xval_ip1;
  double yval_i;
  double yval_ip1;
  CPLOT_enumColor color;

  if( !P )
    return FALSE;
  if( !Series )
    return FALSE;
  if( !Series->X )
    return FALSE;
  if( !Series->Y )
    return FALSE;

  n = Series->n;

  if( !CPLOT_DetermineSeriesStatistics( Series ) )
    return FALSE;

  if( !P->mIsAxesDrawn || P->mOptions.redrawAxes )
  {
    // draw the axes
    if( !CPLOT_DrawAxes( P, Series, CPLOT_BLACK ) )
      return FALSE;
    P->mIsAxesDrawn = TRUE;
  }

  if( P->mOptions.numberOfSeries < P->mSeriesIndex + 1 )
  {
    P->mOptions.numberOfSeries = P->mSeriesIndex+1;
    if( P->mOptions.numberOfSeries <= 3 )
    {
      if( !CPLOT_ResizePlot(P) )
        return FALSE;
    }
  }

  
  // now plot the mPlotData   
  for( i = 0; i < n; i++ )
  {
    xval_i = Series->X[i];
    yval_i = Series->Y[i];

    if( CPLOT_IsNAN( xval_i ) )
      continue;
    if( CPLOT_IsNAN( yval_i ) )
      continue;

    if( xval_i < P->mData.MinX )
      continue;
    if( xval_i > P->mData.MaxX )
      continue;

    x1 = (int)( (xval_i   - P->mData.MinX)*P->mData.ScaleX ) + P->mAxes.StartX;
    y1 = (int)( (yval_i   - P->mData.MinY)*P->mData.ScaleY ) + P->mAxes.StartY;

    if( i == n - 1 )
    {
      xval_ip1 = xval_i;
      yval_ip1 = yval_i;
      x2 = x1;
      y2 = y1;
    }
    else
    {
      xval_ip1 = Series->X[i+1];
      yval_ip1 = Series->Y[i+1];             
      if( CPLOT_IsNAN( xval_ip1 ) )
      {
        xval_ip1 = xval_i;
        yval_ip1 = yval_i;
        x2 = x1;
        y2 = y1;
      }
      else if( CPLOT_IsNAN( yval_ip1 ) )
      {
        xval_ip1 = xval_i;
        yval_ip1 = yval_i;
        x2 = x1;
        y2 = y1;
      }
      else
      {
        x2 = (int)( (xval_ip1 - P->mData.MinX)*P->mData.ScaleX ) + P->mAxes.StartX;
        y2 = (int)( (yval_ip1 - P->mData.MinY)*P->mData.ScaleY ) + P->mAxes.StartY;
      }
    }

    color = Series->color;

    if( x1 <= P->mAxes.StartX - 2)
    {
      continue;
    }
    if( x1 >= P->mAxes.FinishX + 2)
    {
      continue;
    }
    if( y1 <= P->mAxes.StartY - 2)
    {
      if( Series->markOutlierData )
      {
        // watch for +infinity values.
        if( CPLOT_IsPostiveINF( yval_i ) )
        {
          y1 = P->mAxes.FinishY + 2;
          if(  i == n - 1 ) // last point 
          {
            y2 = P->mAxes.FinishY;
          }
        }
        else
        {
          y1 = P->mAxes.StartY - 2;
          if(  i == n - 1 ) // last point 
          {
            y2 = P->mAxes.StartY;
          }
        }
        color = CPLOT_CYAN;         
      }
      else
      {
        continue;
      }
    }
    if( y1 >= P->mAxes.FinishY + 2)
    {
      if( Series->markOutlierData )
      {
        // watch for -infinity values.
        if( CPLOT_IsNegativeINF( yval_i ) )
        {
          y1 = P->mAxes.StartY - 2;   
          if( i == n - 1 ) // last point 
          {
            y2 = P->mAxes.StartY;
          }
        }
        else 
        {
          y1 = P->mAxes.FinishY + 2;
          if( i == n - 1 ) // last point 
          {
            y2 = P->mAxes.FinishY;
          }
        }
        color = CPLOT_CYAN;         
      }
      else
      {
        continue;
      }
    }         

    if( xval_i < P->mOptions.endOfWarmupEpoch )
    {
      if( !CPLOT_DrawPoint( P, x1, y1, CPLOT_LIGHTGREY ) )
        return FALSE;
    }
    else
    {
      if( !CPLOT_DrawPoint( P, x1, y1, color ) )
        return FALSE;
    }

    if( x2 < P->mAxes.StartX )
    {
      if( CPLOT_IsPostiveINF( xval_ip1 ) )
      {
        x2 = P->mAxes.FinishX;
      }
      else
      {
        x2 = P->mAxes.StartX;
      }        
    }

    if( x2 > P->mAxes.FinishX )
    {
      if( CPLOT_IsNegativeINF( xval_ip1 ) )
      {
        x2 = P->mAxes.StartX;
      }
      else
      {
        x2 = P->mAxes.FinishX;
      }
    }

    if( y2 < P->mAxes.StartY )
    {
      if( CPLOT_IsPostiveINF( yval_ip1 ) )
      {
        y2 = P->mAxes.FinishY;
      }
      else
      {
        y2 = P->mAxes.StartY;
      }
    }

    if( y2 > P->mAxes.FinishY )
    {
      if( CPLOT_IsNegativeINF( yval_ip1 ) )
      {
        y2 = P->mAxes.StartY;
      }
      else
      {
        y2 = P->mAxes.FinishY;
      }
    }

    if( Series->connected )
    {
      if( xval_i < P->mOptions.endOfWarmupEpoch )
      {
        if( !CPLOT_DrawLine( P, x1, y1, x2, y2, CPLOT_LIGHTGREY ) )
          return FALSE;
      }
      else
      {
        if( !CPLOT_DrawLine( P, x1, y1, x2, y2, Series->color ) )
          return FALSE;
      }
    }
  }

  if( Series->label != NULL )
  {
    if( strlen( Series->label ) > 0 )
    {
      if( !CPLOT_DrawLegendLabel( P, Series->label, Series->units, Series->color ) )
        return FALSE;
    }
  }

  if( P->mOptions.plotStatistics )
  {
    if( !CPLOT_DrawStats( P, Series ) )
      return FALSE;    
  }

  P->mSeriesIndex++;
  return TRUE;
}



